"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./hooks/useChallenge.ts":
/*!*******************************!*\
  !*** ./hooks/useChallenge.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChallenge: () => (/* binding */ useChallenge)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"../node_modules/@solana/wallet-adapter-react/lib/esm/index.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"../node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _useProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useProgram */ \"./hooks/useProgram.ts\");\n//src/hooks/useChallenge.ts\n // Add useEffect\n\n\n\nconst useChallenge = ()=>{\n    const wallet = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__.useWallet)();\n    const { program } = (0,_useProgram__WEBPACK_IMPORTED_MODULE_2__.useProgram)();\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [challengeStatus, setChallengeStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"idle\");\n    const [challengeAccount, setChallengeAccount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    // const [challenges, setChallenges] = useState<Challenge[]>([]);\n    const [lastFetch, setLastFetch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // At the top of useChallenge.ts\n    const getStoredChallenges = ()=>{\n        const stored = localStorage.getItem(\"challenges\");\n        return stored ? JSON.parse(stored) : [];\n    };\n    const [challenges, setChallenges] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getStoredChallenges());\n    const createChallenge = async (param)=>{\n        let { wagerAmount, lichessUsername } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return null;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            setChallengeStatus(\"creating\");\n            const challengeKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.unique();\n            const statsHash = new Uint8Array(32).fill(1);\n            const lamports = Math.round(wagerAmount * 1e9);\n            const createChallengeIx = await program.methods.createChallenge(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(lamports.toString()), statsHash).accounts({\n                challenge: challengeKeypair,\n                creator: wallet.publicKey,\n                systemProgram: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.SystemProgram.programId\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(createChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature, \"confirmed\");\n            console.log(\"Transaction signature:\", signature);\n            const newChallenge = {\n                id: challengeKeypair.toString(),\n                creator: wallet.publicKey.toString(),\n                lichessUsername,\n                wagerAmount,\n                isComplete: false,\n                stats: {\n                    matchId: \"\",\n                    playerStats: {\n                        result: \"draw\",\n                        variant: \"Standard\",\n                        speed: \"Unknown\"\n                    }\n                }\n            };\n            setChallenges((prev)=>{\n                const updatedChallenges = [\n                    ...prev,\n                    newChallenge\n                ];\n                console.log(\"Challenges updated in createChallenge:\", updatedChallenges); // New debug log\n                localStorage.setItem(\"challenges\", JSON.stringify(updatedChallenges)); // Ensure persistence\n                return updatedChallenges;\n            });\n            setChallengeStatus(\"active\");\n            setChallengeAccount(challengeKeypair.toString());\n            await getChallenges(); // Try to fetch updated list\n            return challengeKeypair.toString();\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Failed to create challenge\";\n            console.error(\"Create challenge error:\", errorMessage);\n            setError(errorMessage);\n            setChallengeStatus(\"idle\");\n            return null;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const getChallenges = async ()=>{\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return [];\n        }\n        const now = Date.now();\n        if (now - lastFetch < 10000) {\n            console.log(\"Rate limit hit, skipping fetch\");\n            return challenges;\n        }\n        try {\n            setLoading(true);\n            const filters = [\n                {\n                    memcmp: {\n                        offset: 8,\n                        bytes: wallet.publicKey.toString()\n                    }\n                }\n            ];\n            console.log(\"Attempting to fetch challenges with filters:\", filters); // Debug\n            const allChallenges = await program.account.challenge.all(filters);\n            const challengeList = allChallenges.map((account)=>({\n                    id: account.publicKey.toString(),\n                    creator: account.account.creator.toString(),\n                    lichessUsername: account.account.lichessUsername || \"\",\n                    wagerAmount: account.account.wagerAmount.toNumber() / 1e9,\n                    isComplete: account.account.isComplete || false,\n                    stats: account.account.stats || {\n                        matchId: \"\",\n                        playerStats: {\n                            result: \"draw\",\n                            variant: \"Standard\",\n                            speed: \"Unknown\"\n                        }\n                    }\n                }));\n            setChallenges(challengeList);\n            localStorage.setItem(\"challenges\", JSON.stringify(challengeList));\n            setLastFetch(now);\n            console.log(\"Successfully fetched challenges:\", challengeList);\n            return challengeList;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Failed to fetch challenges\";\n            if (errorMessage.includes(\"429\")) {\n                console.warn(\"Rate limit hit, retrying after delay...\", errorMessage);\n                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                return getChallenges();\n            }\n            console.error(\"Fetch failed, falling back to localStorage:\", errorMessage);\n            const storedChallenges = getStoredChallenges();\n            setChallenges(storedChallenges);\n            console.log(\"Fallback challenges from localStorage:\", storedChallenges);\n            return storedChallenges;\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChallenge.useEffect\": ()=>{\n            if (wallet.connected) getChallenges();\n        }\n    }[\"useChallenge.useEffect\"], [\n        wallet.connected\n    ]);\n    const acceptChallenge = async (param)=>{\n        let { challengeId, wagerAmount, lichessUsername } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return false;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            const acceptChallengeIx = await program.methods.acceptChallenge().accounts({\n                challenge: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(challengeId),\n                challenger: wallet.publicKey,\n                systemProgram: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.SystemProgram.programId\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(acceptChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature);\n            setChallengeStatus(\"accepted\");\n            return true;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to accept challenge\");\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const completeChallenge = async (param)=>{\n        let { challengeId, winner, stats } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return false;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            const zkProof = new Uint8Array(32).fill(0); // Placeholder for Lichess ZK proof (e.g., game result verification)\n            const completeChallengeIx = await program.methods.completeChallenge(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(winner), zkProof).accounts({\n                challenge: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(challengeId),\n                creator: wallet.publicKey,\n                challenger: wallet.publicKey\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(completeChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature);\n            setChallengeStatus(\"completed\");\n            return true;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to complete challenge\");\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        createChallenge,\n        acceptChallenge,\n        completeChallenge,\n        getChallenges,\n        loading,\n        error,\n        challengeStatus,\n        challengeAccount\n    };\n};\nfunction setLastFetch(now) {\n    throw new Error(\"Function not implemented.\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ21EO1lBQzFDLE1BQU1sRCxZQUFZLE1BQU01QyxPQUFPNkMsZUFBZSxDQUM1Q0gsYUFDQXpDLFFBQVE2QyxRQUFRLENBQUNDLFVBQVU7WUFHN0IsTUFBTTlDLFFBQVE2QyxRQUFRLENBQUNDLFVBQVUsQ0FBQ0Msa0JBQWtCLENBQUNKO1lBQ3JEckMsbUJBQW1CO1lBQ25CLE9BQU87UUFDVCxFQUFFLE9BQU8wRCxLQUFLO1lBQ1o1RCxTQUNFNEQsZUFBZUUsUUFBUUYsSUFBSUcsT0FBTyxHQUFHO1lBRXZDLE9BQU87UUFDVCxTQUFVO1lBQ1JqRSxXQUFXO1FBQ2I7SUFDRjtJQUVBLE9BQU87UUFDTGlCO1FBQ0FtRTtRQUNBSTtRQUNBM0I7UUFDQTlEO1FBQ0FFO1FBQ0FFO1FBQ0FFO0lBQ0Y7QUFDRixFQUFFO0FBQ0YsU0FBU0csYUFBYTBELEdBQVc7SUFDL0IsTUFBTSxJQUFJRixNQUFNO0FBQ2xCIiwic291cmNlcyI6WyIvaG9tZS9kYi9Qcm9qZWN0cy9EdWVsQmV0L2Zyb250ZW5kL2hvb2tzL3VzZUNoYWxsZW5nZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL3NyYy9ob29rcy91c2VDaGFsbGVuZ2UudHNcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiOyAvLyBBZGQgdXNlRWZmZWN0XG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tIFwiQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdFwiO1xuaW1wb3J0IHsgUHVibGljS2V5LCBUcmFuc2FjdGlvbiwgU3lzdGVtUHJvZ3JhbSB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCB7IHVzZVByb2dyYW0gfSBmcm9tIFwiLi91c2VQcm9ncmFtXCI7XG5pbXBvcnQge1xuICBDcmVhdGVDaGFsbGVuZ2VQYXJhbXMsXG4gIEFjY2VwdENoYWxsZW5nZVBhcmFtcyxcbiAgQ29tcGxldGVDaGFsbGVuZ2VQYXJhbXMsXG4gIENoYWxsZW5nZVN0YXR1cyxcbiAgQ2hhbGxlbmdlLFxufSBmcm9tIFwiQC90eXBlc1wiO1xuXG5leHBvcnQgY29uc3QgdXNlQ2hhbGxlbmdlID0gKCkgPT4ge1xuICBjb25zdCB3YWxsZXQgPSB1c2VXYWxsZXQoKTtcbiAgY29uc3QgeyBwcm9ncmFtIH0gPSB1c2VQcm9ncmFtKCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2NoYWxsZW5nZVN0YXR1cywgc2V0Q2hhbGxlbmdlU3RhdHVzXSA9XG4gICAgdXNlU3RhdGU8Q2hhbGxlbmdlU3RhdHVzPihcImlkbGVcIik7XG4gIGNvbnN0IFtjaGFsbGVuZ2VBY2NvdW50LCBzZXRDaGFsbGVuZ2VBY2NvdW50XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIC8vIGNvbnN0IFtjaGFsbGVuZ2VzLCBzZXRDaGFsbGVuZ2VzXSA9IHVzZVN0YXRlPENoYWxsZW5nZVtdPihbXSk7XG4gIGNvbnN0IFtsYXN0RmV0Y2gsIHNldExhc3RGZXRjaF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuXG4gIC8vIEF0IHRoZSB0b3Agb2YgdXNlQ2hhbGxlbmdlLnRzXG4gIGNvbnN0IGdldFN0b3JlZENoYWxsZW5nZXMgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJjaGFsbGVuZ2VzXCIpO1xuICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBbXTtcbiAgfTtcblxuICBjb25zdCBbY2hhbGxlbmdlcywgc2V0Q2hhbGxlbmdlc10gPSB1c2VTdGF0ZTxDaGFsbGVuZ2VbXT4oXG4gICAgZ2V0U3RvcmVkQ2hhbGxlbmdlcygpXG4gICk7XG5cbiAgY29uc3QgY3JlYXRlQ2hhbGxlbmdlID0gYXN5bmMgKHtcbiAgICB3YWdlckFtb3VudCxcbiAgICBsaWNoZXNzVXNlcm5hbWUsXG4gIH06IENyZWF0ZUNoYWxsZW5nZVBhcmFtcykgPT4ge1xuICAgIGlmICghd2FsbGV0LmNvbm5lY3RlZCB8fCAhcHJvZ3JhbSkge1xuICAgICAgc2V0RXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICBzZXRDaGFsbGVuZ2VTdGF0dXMoXCJjcmVhdGluZ1wiKTtcblxuICAgICAgY29uc3QgY2hhbGxlbmdlS2V5cGFpciA9IFB1YmxpY0tleS51bmlxdWUoKTtcbiAgICAgIGNvbnN0IHN0YXRzSGFzaCA9IG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDEpO1xuICAgICAgY29uc3QgbGFtcG9ydHMgPSBNYXRoLnJvdW5kKHdhZ2VyQW1vdW50ICogMWU5KTtcblxuICAgICAgY29uc3QgY3JlYXRlQ2hhbGxlbmdlSXggPSBhd2FpdCBwcm9ncmFtLm1ldGhvZHNcbiAgICAgICAgLmNyZWF0ZUNoYWxsZW5nZShuZXcgUHVibGljS2V5KGxhbXBvcnRzLnRvU3RyaW5nKCkpLCBzdGF0c0hhc2gpXG4gICAgICAgIC5hY2NvdW50cyh7XG4gICAgICAgICAgY2hhbGxlbmdlOiBjaGFsbGVuZ2VLZXlwYWlyLFxuICAgICAgICAgIGNyZWF0b3I6IHdhbGxldC5wdWJsaWNLZXkhLFxuICAgICAgICAgIHN5c3RlbVByb2dyYW06IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgICB9KVxuICAgICAgICAuaW5zdHJ1Y3Rpb24oKTtcblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoY3JlYXRlQ2hhbGxlbmdlSXgpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbihcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvblxuICAgICAgKTtcbiAgICAgIGF3YWl0IHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgXCJjb25maXJtZWRcIlxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiVHJhbnNhY3Rpb24gc2lnbmF0dXJlOlwiLCBzaWduYXR1cmUpO1xuXG4gICAgICBjb25zdCBuZXdDaGFsbGVuZ2U6IENoYWxsZW5nZSA9IHtcbiAgICAgICAgaWQ6IGNoYWxsZW5nZUtleXBhaXIudG9TdHJpbmcoKSxcbiAgICAgICAgY3JlYXRvcjogd2FsbGV0LnB1YmxpY0tleSEudG9TdHJpbmcoKSxcbiAgICAgICAgbGljaGVzc1VzZXJuYW1lLFxuICAgICAgICB3YWdlckFtb3VudCxcbiAgICAgICAgaXNDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgbWF0Y2hJZDogXCJcIixcbiAgICAgICAgICBwbGF5ZXJTdGF0czoge1xuICAgICAgICAgICAgcmVzdWx0OiBcImRyYXdcIixcbiAgICAgICAgICAgIHZhcmlhbnQ6IFwiU3RhbmRhcmRcIixcbiAgICAgICAgICAgIHNwZWVkOiBcIlVua25vd25cIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIHNldENoYWxsZW5nZXMoKHByZXYpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZENoYWxsZW5nZXMgPSBbLi4ucHJldiwgbmV3Q2hhbGxlbmdlXTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJDaGFsbGVuZ2VzIHVwZGF0ZWQgaW4gY3JlYXRlQ2hhbGxlbmdlOlwiLFxuICAgICAgICAgIHVwZGF0ZWRDaGFsbGVuZ2VzXG4gICAgICAgICk7IC8vIE5ldyBkZWJ1ZyBsb2dcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJjaGFsbGVuZ2VzXCIsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRDaGFsbGVuZ2VzKSk7IC8vIEVuc3VyZSBwZXJzaXN0ZW5jZVxuICAgICAgICByZXR1cm4gdXBkYXRlZENoYWxsZW5nZXM7XG4gICAgICB9KTtcbiAgICAgIHNldENoYWxsZW5nZVN0YXR1cyhcImFjdGl2ZVwiKTtcbiAgICAgIHNldENoYWxsZW5nZUFjY291bnQoY2hhbGxlbmdlS2V5cGFpci50b1N0cmluZygpKTtcbiAgICAgIGF3YWl0IGdldENoYWxsZW5nZXMoKTsgLy8gVHJ5IHRvIGZldGNoIHVwZGF0ZWQgbGlzdFxuICAgICAgcmV0dXJuIGNoYWxsZW5nZUtleXBhaXIudG9TdHJpbmcoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBjcmVhdGUgY2hhbGxlbmdlXCI7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ3JlYXRlIGNoYWxsZW5nZSBlcnJvcjpcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICBzZXRDaGFsbGVuZ2VTdGF0dXMoXCJpZGxlXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRDaGFsbGVuZ2VzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghd2FsbGV0LmNvbm5lY3RlZCB8fCAhcHJvZ3JhbSkge1xuICAgICAgc2V0RXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSBsYXN0RmV0Y2ggPCAxMDAwMCkge1xuICAgICAgY29uc29sZS5sb2coXCJSYXRlIGxpbWl0IGhpdCwgc2tpcHBpbmcgZmV0Y2hcIik7XG4gICAgICByZXR1cm4gY2hhbGxlbmdlcztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIGNvbnN0IGZpbHRlcnMgPSBbXG4gICAgICAgIHsgbWVtY21wOiB7IG9mZnNldDogOCwgYnl0ZXM6IHdhbGxldC5wdWJsaWNLZXkhLnRvU3RyaW5nKCkgfSB9LFxuICAgICAgXTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQXR0ZW1wdGluZyB0byBmZXRjaCBjaGFsbGVuZ2VzIHdpdGggZmlsdGVyczpcIiwgZmlsdGVycyk7IC8vIERlYnVnXG4gICAgICBjb25zdCBhbGxDaGFsbGVuZ2VzID0gYXdhaXQgcHJvZ3JhbS5hY2NvdW50LmNoYWxsZW5nZS5hbGwoZmlsdGVycyk7XG4gICAgICBjb25zdCBjaGFsbGVuZ2VMaXN0ID0gYWxsQ2hhbGxlbmdlcy5tYXAoKGFjY291bnQpID0+ICh7XG4gICAgICAgIGlkOiBhY2NvdW50LnB1YmxpY0tleS50b1N0cmluZygpLFxuICAgICAgICBjcmVhdG9yOiBhY2NvdW50LmFjY291bnQuY3JlYXRvci50b1N0cmluZygpLFxuICAgICAgICBsaWNoZXNzVXNlcm5hbWU6IGFjY291bnQuYWNjb3VudC5saWNoZXNzVXNlcm5hbWUgfHwgXCJcIixcbiAgICAgICAgd2FnZXJBbW91bnQ6IGFjY291bnQuYWNjb3VudC53YWdlckFtb3VudC50b051bWJlcigpIC8gMWU5LFxuICAgICAgICBpc0NvbXBsZXRlOiBhY2NvdW50LmFjY291bnQuaXNDb21wbGV0ZSB8fCBmYWxzZSxcbiAgICAgICAgc3RhdHM6IGFjY291bnQuYWNjb3VudC5zdGF0cyB8fCB7XG4gICAgICAgICAgbWF0Y2hJZDogXCJcIixcbiAgICAgICAgICBwbGF5ZXJTdGF0czoge1xuICAgICAgICAgICAgcmVzdWx0OiBcImRyYXdcIixcbiAgICAgICAgICAgIHZhcmlhbnQ6IFwiU3RhbmRhcmRcIixcbiAgICAgICAgICAgIHNwZWVkOiBcIlVua25vd25cIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSkpO1xuICAgICAgc2V0Q2hhbGxlbmdlcyhjaGFsbGVuZ2VMaXN0KTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY2hhbGxlbmdlc1wiLCBKU09OLnN0cmluZ2lmeShjaGFsbGVuZ2VMaXN0KSk7XG4gICAgICBzZXRMYXN0RmV0Y2gobm93KTtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IGZldGNoZWQgY2hhbGxlbmdlczpcIiwgY2hhbGxlbmdlTGlzdCk7XG4gICAgICByZXR1cm4gY2hhbGxlbmdlTGlzdDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBmZXRjaCBjaGFsbGVuZ2VzXCI7XG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiNDI5XCIpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlJhdGUgbGltaXQgaGl0LCByZXRyeWluZyBhZnRlciBkZWxheS4uLlwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XG4gICAgICAgIHJldHVybiBnZXRDaGFsbGVuZ2VzKCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIkZldGNoIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIGxvY2FsU3RvcmFnZTpcIixcbiAgICAgICAgZXJyb3JNZXNzYWdlXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RvcmVkQ2hhbGxlbmdlcyA9IGdldFN0b3JlZENoYWxsZW5nZXMoKTtcbiAgICAgIHNldENoYWxsZW5nZXMoc3RvcmVkQ2hhbGxlbmdlcyk7XG4gICAgICBjb25zb2xlLmxvZyhcIkZhbGxiYWNrIGNoYWxsZW5nZXMgZnJvbSBsb2NhbFN0b3JhZ2U6XCIsIHN0b3JlZENoYWxsZW5nZXMpO1xuICAgICAgcmV0dXJuIHN0b3JlZENoYWxsZW5nZXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh3YWxsZXQuY29ubmVjdGVkKSBnZXRDaGFsbGVuZ2VzKCk7XG4gIH0sIFt3YWxsZXQuY29ubmVjdGVkXSk7XG5cbiAgY29uc3QgYWNjZXB0Q2hhbGxlbmdlID0gYXN5bmMgKHtcbiAgICBjaGFsbGVuZ2VJZCxcbiAgICB3YWdlckFtb3VudCxcbiAgICBsaWNoZXNzVXNlcm5hbWUsIC8vIFJlcGxhY2VkIHJpb3RJZCB3aXRoIGxpY2hlc3NVc2VybmFtZVxuICB9OiBBY2NlcHRDaGFsbGVuZ2VQYXJhbXMpID0+IHtcbiAgICBpZiAoIXdhbGxldC5jb25uZWN0ZWQgfHwgIXByb2dyYW0pIHtcbiAgICAgIHNldEVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgY29uc3QgYWNjZXB0Q2hhbGxlbmdlSXggPSBhd2FpdCBwcm9ncmFtLm1ldGhvZHNcbiAgICAgICAgLmFjY2VwdENoYWxsZW5nZSgpXG4gICAgICAgIC5hY2NvdW50cyh7XG4gICAgICAgICAgY2hhbGxlbmdlOiBuZXcgUHVibGljS2V5KGNoYWxsZW5nZUlkKSxcbiAgICAgICAgICBjaGFsbGVuZ2VyOiB3YWxsZXQucHVibGljS2V5ISxcbiAgICAgICAgICBzeXN0ZW1Qcm9ncmFtOiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgfSlcbiAgICAgICAgLmluc3RydWN0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGFjY2VwdENoYWxsZW5nZUl4KTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24oXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBwcm9ncmFtLnByb3ZpZGVyLmNvbm5lY3Rpb25cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlKTtcbiAgICAgIHNldENoYWxsZW5nZVN0YXR1cyhcImFjY2VwdGVkXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRFcnJvcihcbiAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiRmFpbGVkIHRvIGFjY2VwdCBjaGFsbGVuZ2VcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNvbXBsZXRlQ2hhbGxlbmdlID0gYXN5bmMgKHtcbiAgICBjaGFsbGVuZ2VJZCxcbiAgICB3aW5uZXIsXG4gICAgc3RhdHMsIC8vIFJlbW92ZWQgc3BlY2lmaWMgTG9MIHN0YXRzIChraWxscywgZGVhdGhzLCBhc3Npc3RzKSwga2VlcGluZyBhcyBnZW5lcmljIHN0YXRzXG4gIH06IENvbXBsZXRlQ2hhbGxlbmdlUGFyYW1zKSA9PiB7XG4gICAgaWYgKCF3YWxsZXQuY29ubmVjdGVkIHx8ICFwcm9ncmFtKSB7XG4gICAgICBzZXRFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnN0IHprUHJvb2YgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgwKTsgLy8gUGxhY2Vob2xkZXIgZm9yIExpY2hlc3MgWksgcHJvb2YgKGUuZy4sIGdhbWUgcmVzdWx0IHZlcmlmaWNhdGlvbilcblxuICAgICAgY29uc3QgY29tcGxldGVDaGFsbGVuZ2VJeCA9IGF3YWl0IHByb2dyYW0ubWV0aG9kc1xuICAgICAgICAuY29tcGxldGVDaGFsbGVuZ2UobmV3IFB1YmxpY0tleSh3aW5uZXIpLCB6a1Byb29mKVxuICAgICAgICAuYWNjb3VudHMoe1xuICAgICAgICAgIGNoYWxsZW5nZTogbmV3IFB1YmxpY0tleShjaGFsbGVuZ2VJZCksXG4gICAgICAgICAgY3JlYXRvcjogd2FsbGV0LnB1YmxpY0tleSEsIC8vIEFzc3VtaW5nIGNyZWF0b3Igb3IgY2hhbGxlbmdlciBjYW4gY29tcGxldGUsIGFkanVzdCBiYXNlZCBvbiB5b3VyIHByb2dyYW0gbG9naWNcbiAgICAgICAgICBjaGFsbGVuZ2VyOiB3YWxsZXQucHVibGljS2V5ISxcbiAgICAgICAgfSlcbiAgICAgICAgLmluc3RydWN0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGNvbXBsZXRlQ2hhbGxlbmdlSXgpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbihcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvblxuICAgICAgKTtcblxuICAgICAgYXdhaXQgcHJvZ3JhbS5wcm92aWRlci5jb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUpO1xuICAgICAgc2V0Q2hhbGxlbmdlU3RhdHVzKFwiY29tcGxldGVkXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRFcnJvcihcbiAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiRmFpbGVkIHRvIGNvbXBsZXRlIGNoYWxsZW5nZVwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDaGFsbGVuZ2UsXG4gICAgYWNjZXB0Q2hhbGxlbmdlLFxuICAgIGNvbXBsZXRlQ2hhbGxlbmdlLFxuICAgIGdldENoYWxsZW5nZXMsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBjaGFsbGVuZ2VTdGF0dXMsXG4gICAgY2hhbGxlbmdlQWNjb3VudCxcbiAgfTtcbn07XG5mdW5jdGlvbiBzZXRMYXN0RmV0Y2gobm93OiBudW1iZXIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbm90IGltcGxlbWVudGVkLlwiKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVdhbGxldCIsIlB1YmxpY0tleSIsIlRyYW5zYWN0aW9uIiwiU3lzdGVtUHJvZ3JhbSIsInVzZVByb2dyYW0iLCJ1c2VDaGFsbGVuZ2UiLCJ3YWxsZXQiLCJwcm9ncmFtIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiY2hhbGxlbmdlU3RhdHVzIiwic2V0Q2hhbGxlbmdlU3RhdHVzIiwiY2hhbGxlbmdlQWNjb3VudCIsInNldENoYWxsZW5nZUFjY291bnQiLCJsYXN0RmV0Y2giLCJzZXRMYXN0RmV0Y2giLCJnZXRTdG9yZWRDaGFsbGVuZ2VzIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImNoYWxsZW5nZXMiLCJzZXRDaGFsbGVuZ2VzIiwiY3JlYXRlQ2hhbGxlbmdlIiwid2FnZXJBbW91bnQiLCJsaWNoZXNzVXNlcm5hbWUiLCJjb25uZWN0ZWQiLCJjaGFsbGVuZ2VLZXlwYWlyIiwidW5pcXVlIiwic3RhdHNIYXNoIiwiVWludDhBcnJheSIsImZpbGwiLCJsYW1wb3J0cyIsIk1hdGgiLCJyb3VuZCIsImNyZWF0ZUNoYWxsZW5nZUl4IiwibWV0aG9kcyIsInRvU3RyaW5nIiwiYWNjb3VudHMiLCJjaGFsbGVuZ2UiLCJjcmVhdG9yIiwicHVibGljS2V5Iiwic3lzdGVtUHJvZ3JhbSIsInByb2dyYW1JZCIsImluc3RydWN0aW9uIiwidHJhbnNhY3Rpb24iLCJhZGQiLCJzaWduYXR1cmUiLCJzZW5kVHJhbnNhY3Rpb24iLCJwcm92aWRlciIsImNvbm5lY3Rpb24iLCJjb25maXJtVHJhbnNhY3Rpb24iLCJjb25zb2xlIiwibG9nIiwibmV3Q2hhbGxlbmdlIiwiaWQiLCJpc0NvbXBsZXRlIiwic3RhdHMiLCJtYXRjaElkIiwicGxheWVyU3RhdHMiLCJyZXN1bHQiLCJ2YXJpYW50Iiwic3BlZWQiLCJwcmV2IiwidXBkYXRlZENoYWxsZW5nZXMiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZ2V0Q2hhbGxlbmdlcyIsImVyciIsImVycm9yTWVzc2FnZSIsIkVycm9yIiwibWVzc2FnZSIsIm5vdyIsIkRhdGUiLCJmaWx0ZXJzIiwibWVtY21wIiwib2Zmc2V0IiwiYnl0ZXMiLCJhbGxDaGFsbGVuZ2VzIiwiYWNjb3VudCIsImFsbCIsImNoYWxsZW5nZUxpc3QiLCJtYXAiLCJ0b051bWJlciIsImluY2x1ZGVzIiwid2FybiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInN0b3JlZENoYWxsZW5nZXMiLCJhY2NlcHRDaGFsbGVuZ2UiLCJjaGFsbGVuZ2VJZCIsImFjY2VwdENoYWxsZW5nZUl4IiwiY2hhbGxlbmdlciIsImNvbXBsZXRlQ2hhbGxlbmdlIiwid2lubmVyIiwiemtQcm9vZiIsImNvbXBsZXRlQ2hhbGxlbmdlSXgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./hooks/useChallenge.ts\n"));

/***/ })

});