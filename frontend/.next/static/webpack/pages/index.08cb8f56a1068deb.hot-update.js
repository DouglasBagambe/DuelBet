"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./hooks/useChallenge.ts":
/*!*******************************!*\
  !*** ./hooks/useChallenge.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChallenge: () => (/* binding */ useChallenge)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"../node_modules/@solana/wallet-adapter-react/lib/esm/index.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"../node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _useProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useProgram */ \"./hooks/useProgram.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../node_modules/buffer/index.js\")[\"Buffer\"];\n// frontend/hooks/useChallenge.ts\n\n\n\n\n// export interface CreateChallengeParams {\n//   wagerAmount: number;\n//   lichessUsername: string;\n//   metadata?: string; // Optional metadata (e.g., Lichess link)\n//   stats?: LichessMatchStats;\n// }\nconst useChallenge = ()=>{\n    const wallet = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__.useWallet)();\n    const { program } = (0,_useProgram__WEBPACK_IMPORTED_MODULE_2__.useProgram)();\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [challengeStatus, setChallengeStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"idle\");\n    const [challenges, setChallenges] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [lastFetch, setLastFetch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const createChallenge = async (param)=>{\n        let { wagerAmount, lichessUsername, metadata = \"\", stats } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return null;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            setChallengeStatus(\"creating\");\n            const challengeKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.unique();\n            const statsHash = new Uint8Array(32);\n            if (stats === null || stats === void 0 ? void 0 : stats.matchId) {\n                const hash = (__webpack_require__(/*! @solana/web3.js */ \"../node_modules/@solana/web3.js/lib/index.browser.esm.js\").hash)(stats.matchId);\n                statsHash.set(hash.slice(0, 32));\n            }\n            const createChallengeIx = await program.methods.createChallenge(wagerAmount, statsHash, metadata) // Pass metadata\n            .accounts({\n                challenge: challengeKeypair,\n                creator: wallet.publicKey,\n                systemProgram: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.SystemProgram.programId\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(createChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature, \"confirmed\");\n            console.log(\"Challenge created, signature:\", signature);\n            const newChallenge = {\n                id: challengeKeypair.toString(),\n                creator: wallet.publicKey.toString(),\n                lichessUsername,\n                wagerAmount,\n                isComplete: false,\n                isActive: true,\n                challenger: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.default.toString(),\n                createdAt: Date.now() / 1000,\n                metadata,\n                stats: stats || {\n                    matchId: \"\",\n                    playerStats: {\n                        result: \"draw\",\n                        variant: \"Standard\",\n                        speed: \"Unknown\"\n                    }\n                }\n            };\n            setChallenges((prev)=>[\n                    ...prev,\n                    newChallenge\n                ]);\n            await getChallenges(); // Fetch updated on-chain list\n            return challengeKeypair.toString();\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to create challenge\");\n            return null;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const getChallenges = async ()=>{\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return [];\n        }\n        const now = Date.now();\n        if (now - lastFetch < 10000) {\n            console.log(\"Rate limit hit, skipping fetch\");\n            return challenges;\n        }\n        try {\n            setLoading(true);\n            const allChallenges = await program.account.challenge.all();\n            console.log(\"Raw on-chain challenges:\", allChallenges);\n            const challengeList = allChallenges.map((account)=>({\n                    id: account.publicKey.toString(),\n                    creator: account.account.creator.toString(),\n                    lichessUsername: \"\",\n                    wagerAmount: account.account.wagerAmount.toNumber() / 1e9,\n                    isComplete: account.account.isComplete,\n                    isActive: account.account.isActive,\n                    challenger: account.account.challenger.toString(),\n                    createdAt: account.account.createdAt.toNumber(),\n                    metadata: account.account.metadata,\n                    stats: {\n                        matchId: \"\",\n                        playerStats: {\n                            result: \"draw\",\n                            variant: \"Standard\",\n                            speed: \"Unknown\"\n                        }\n                    }\n                }));\n            setChallenges(challengeList);\n            setLastFetch(now);\n            console.log(\"Fetched challenges:\", challengeList);\n            return challengeList;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to fetch challenges\");\n            return challenges;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const acceptChallenge = async (param)=>{\n        let { challengeId } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return false;\n        }\n        try {\n            setLoading(true);\n            const acceptChallengeIx = await program.methods.acceptChallenge().accounts({\n                challenge: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(challengeId),\n                challenger: wallet.publicKey,\n                systemProgram: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.SystemProgram.programId\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(acceptChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature);\n            console.log(\"Challenge accepted, signature:\", signature);\n            await getChallenges();\n            return true;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to accept challenge\");\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const completeChallenge = async (param)=>{\n        let { challengeId, winner, stats } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return false;\n        }\n        try {\n            setLoading(true);\n            const zkProof = Buffer.from(\"1-0\"); // Placeholder, adjust based on actual game result\n            const completeChallengeIx = await program.methods.completeChallenge(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(winner), zkProof).accounts({\n                challenge: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(challengeId),\n                creator: wallet.publicKey,\n                challenger: wallet.publicKey\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(completeChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature);\n            console.log(\"Challenge completed, signature:\", signature);\n            await getChallenges();\n            return true;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to complete challenge\");\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChallenge.useEffect\": ()=>{\n            if (wallet.connected) getChallenges();\n        }\n    }[\"useChallenge.useEffect\"], [\n        wallet.connected\n    ]);\n    return {\n        createChallenge,\n        acceptChallenge,\n        completeChallenge,\n        getChallenges,\n        loading,\n        error,\n        challengeStatus,\n        challenges\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VCxPQUFPO1FBQ1Q7UUFFQSxJQUFJO1lBQ0ZGLFdBQVc7WUFDWCxNQUFNd0UsVUFBVUMsTUFBTUEsQ0FBQ0MsSUFBSSxDQUFDLFFBQVEsa0RBQWtEO1lBQ3RGLE1BQU1DLHNCQUFzQixNQUFNN0UsUUFBUTJCLE9BQU8sQ0FDOUM2QyxpQkFBaUIsQ0FBQyxJQUFJOUUsc0RBQVNBLENBQUMrRSxTQUFTQyxTQUN6QzlDLFFBQVEsQ0FBQztnQkFDUkMsV0FBVyxJQUFJbkMsc0RBQVNBLENBQUM0RTtnQkFDekJ4QyxTQUFTL0IsT0FBT2dDLFNBQVM7Z0JBQ3pCa0IsWUFBWWxELE9BQU9nQyxTQUFTO1lBQzlCLEdBQ0NHLFdBQVc7WUFFZCxNQUFNQyxjQUFjLElBQUl4Qyx3REFBV0EsR0FBR3lDLEdBQUcsQ0FBQ3lDO1lBQzFDLE1BQU14QyxZQUFZLE1BQU10QyxPQUFPdUMsZUFBZSxDQUM1Q0gsYUFDQW5DLFFBQVF1QyxRQUFRLENBQUNDLFVBQVU7WUFFN0IsTUFBTXhDLFFBQVF1QyxRQUFRLENBQUNDLFVBQVUsQ0FBQ0Msa0JBQWtCLENBQUNKO1lBQ3JESyxRQUFRQyxHQUFHLENBQUMsbUNBQW1DTjtZQUMvQyxNQUFNc0I7WUFDTixPQUFPO1FBQ1QsRUFBRSxPQUFPQyxLQUFLO1lBQ1p4RCxTQUNFd0QsZUFBZUMsUUFBUUQsSUFBSUUsT0FBTyxHQUFHO1lBRXZDLE9BQU87UUFDVCxTQUFVO1lBQ1I1RCxXQUFXO1FBQ2I7SUFDRjtJQUVBWCxnREFBU0E7a0NBQUM7WUFDUixJQUFJUSxPQUFPaUIsU0FBUyxFQUFFMkM7UUFDeEI7aUNBQUc7UUFBQzVELE9BQU9pQixTQUFTO0tBQUM7SUFFckIsT0FBTztRQUNMTDtRQUNBMEQ7UUFDQUc7UUFDQWI7UUFDQTFEO1FBQ0FFO1FBQ0FFO1FBQ0FFO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvaG9tZS9kYi9Qcm9qZWN0cy9EdWVsQmV0L2Zyb250ZW5kL2hvb2tzL3VzZUNoYWxsZW5nZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmcm9udGVuZC9ob29rcy91c2VDaGFsbGVuZ2UudHNcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVdhbGxldCB9IGZyb20gXCJAc29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0XCI7XG5pbXBvcnQgeyBQdWJsaWNLZXksIFRyYW5zYWN0aW9uLCBTeXN0ZW1Qcm9ncmFtIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IHsgdXNlUHJvZ3JhbSB9IGZyb20gXCIuL3VzZVByb2dyYW1cIjtcbmltcG9ydCB7XG4gIENyZWF0ZUNoYWxsZW5nZVBhcmFtcyxcbiAgQWNjZXB0Q2hhbGxlbmdlUGFyYW1zLFxuICBDb21wbGV0ZUNoYWxsZW5nZVBhcmFtcyxcbiAgQ2hhbGxlbmdlU3RhdHVzLFxuICBDaGFsbGVuZ2UsXG4gIExpY2hlc3NNYXRjaFN0YXRzLFxufSBmcm9tIFwiQC90eXBlc1wiO1xuXG4vLyBleHBvcnQgaW50ZXJmYWNlIENyZWF0ZUNoYWxsZW5nZVBhcmFtcyB7XG4vLyAgIHdhZ2VyQW1vdW50OiBudW1iZXI7XG4vLyAgIGxpY2hlc3NVc2VybmFtZTogc3RyaW5nO1xuLy8gICBtZXRhZGF0YT86IHN0cmluZzsgLy8gT3B0aW9uYWwgbWV0YWRhdGEgKGUuZy4sIExpY2hlc3MgbGluaylcbi8vICAgc3RhdHM/OiBMaWNoZXNzTWF0Y2hTdGF0cztcbi8vIH1cblxuZXhwb3J0IGNvbnN0IHVzZUNoYWxsZW5nZSA9ICgpID0+IHtcbiAgY29uc3Qgd2FsbGV0ID0gdXNlV2FsbGV0KCk7XG4gIGNvbnN0IHsgcHJvZ3JhbSB9ID0gdXNlUHJvZ3JhbSgpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjaGFsbGVuZ2VTdGF0dXMsIHNldENoYWxsZW5nZVN0YXR1c10gPVxuICAgIHVzZVN0YXRlPENoYWxsZW5nZVN0YXR1cz4oXCJpZGxlXCIpO1xuICBjb25zdCBbY2hhbGxlbmdlcywgc2V0Q2hhbGxlbmdlc10gPSB1c2VTdGF0ZTxDaGFsbGVuZ2VbXT4oW10pO1xuICBjb25zdCBbbGFzdEZldGNoLCBzZXRMYXN0RmV0Y2hdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcblxuICBjb25zdCBjcmVhdGVDaGFsbGVuZ2UgPSBhc3luYyAoe1xuICAgIHdhZ2VyQW1vdW50LFxuICAgIGxpY2hlc3NVc2VybmFtZSxcbiAgICBtZXRhZGF0YSA9IFwiXCIsIC8vIERlZmF1bHQgZW1wdHkgc3RyaW5nIGlmIG5vdCBwcm92aWRlZFxuICAgIHN0YXRzLFxuICB9OiBDcmVhdGVDaGFsbGVuZ2VQYXJhbXMpID0+IHtcbiAgICBpZiAoIXdhbGxldC5jb25uZWN0ZWQgfHwgIXByb2dyYW0pIHtcbiAgICAgIHNldEVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgc2V0Q2hhbGxlbmdlU3RhdHVzKFwiY3JlYXRpbmdcIik7XG5cbiAgICAgIGNvbnN0IGNoYWxsZW5nZUtleXBhaXIgPSBQdWJsaWNLZXkudW5pcXVlKCk7XG4gICAgICBjb25zdCBzdGF0c0hhc2ggPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICBpZiAoc3RhdHM/Lm1hdGNoSWQpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IHJlcXVpcmUoXCJAc29sYW5hL3dlYjMuanNcIikuaGFzaChzdGF0cy5tYXRjaElkKTtcbiAgICAgICAgc3RhdHNIYXNoLnNldChoYXNoLnNsaWNlKDAsIDMyKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNyZWF0ZUNoYWxsZW5nZUl4ID0gYXdhaXQgcHJvZ3JhbS5tZXRob2RzXG4gICAgICAgIC5jcmVhdGVDaGFsbGVuZ2Uod2FnZXJBbW91bnQsIHN0YXRzSGFzaCwgbWV0YWRhdGEpIC8vIFBhc3MgbWV0YWRhdGFcbiAgICAgICAgLmFjY291bnRzKHtcbiAgICAgICAgICBjaGFsbGVuZ2U6IGNoYWxsZW5nZUtleXBhaXIsXG4gICAgICAgICAgY3JlYXRvcjogd2FsbGV0LnB1YmxpY0tleSEsXG4gICAgICAgICAgc3lzdGVtUHJvZ3JhbTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICAgIH0pXG4gICAgICAgIC5pbnN0cnVjdGlvbigpO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChjcmVhdGVDaGFsbGVuZ2VJeCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgcHJvZ3JhbS5wcm92aWRlci5jb25uZWN0aW9uXG4gICAgICApO1xuICAgICAgYXdhaXQgcHJvZ3JhbS5wcm92aWRlci5jb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBcImNvbmZpcm1lZFwiXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coXCJDaGFsbGVuZ2UgY3JlYXRlZCwgc2lnbmF0dXJlOlwiLCBzaWduYXR1cmUpO1xuXG4gICAgICBjb25zdCBuZXdDaGFsbGVuZ2U6IENoYWxsZW5nZSA9IHtcbiAgICAgICAgaWQ6IGNoYWxsZW5nZUtleXBhaXIudG9TdHJpbmcoKSxcbiAgICAgICAgY3JlYXRvcjogd2FsbGV0LnB1YmxpY0tleSEudG9TdHJpbmcoKSxcbiAgICAgICAgbGljaGVzc1VzZXJuYW1lLFxuICAgICAgICB3YWdlckFtb3VudCxcbiAgICAgICAgaXNDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgICBjaGFsbGVuZ2VyOiBQdWJsaWNLZXkuZGVmYXVsdC50b1N0cmluZygpLFxuICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCkgLyAxMDAwLFxuICAgICAgICBtZXRhZGF0YSwgLy8gU3RvcmUgbWV0YWRhdGEgbG9jYWxseVxuICAgICAgICBzdGF0czogc3RhdHMgfHwge1xuICAgICAgICAgIG1hdGNoSWQ6IFwiXCIsXG4gICAgICAgICAgcGxheWVyU3RhdHM6IHtcbiAgICAgICAgICAgIHJlc3VsdDogXCJkcmF3XCIsXG4gICAgICAgICAgICB2YXJpYW50OiBcIlN0YW5kYXJkXCIsXG4gICAgICAgICAgICBzcGVlZDogXCJVbmtub3duXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBzZXRDaGFsbGVuZ2VzKChwcmV2KSA9PiBbLi4ucHJldiwgbmV3Q2hhbGxlbmdlXSk7XG4gICAgICBhd2FpdCBnZXRDaGFsbGVuZ2VzKCk7IC8vIEZldGNoIHVwZGF0ZWQgb24tY2hhaW4gbGlzdFxuICAgICAgcmV0dXJuIGNoYWxsZW5nZUtleXBhaXIudG9TdHJpbmcoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gY3JlYXRlIGNoYWxsZW5nZVwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRDaGFsbGVuZ2VzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghd2FsbGV0LmNvbm5lY3RlZCB8fCAhcHJvZ3JhbSkge1xuICAgICAgc2V0RXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSBsYXN0RmV0Y2ggPCAxMDAwMCkge1xuICAgICAgY29uc29sZS5sb2coXCJSYXRlIGxpbWl0IGhpdCwgc2tpcHBpbmcgZmV0Y2hcIik7XG4gICAgICByZXR1cm4gY2hhbGxlbmdlcztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIGNvbnN0IGFsbENoYWxsZW5nZXMgPSBhd2FpdCBwcm9ncmFtLmFjY291bnQuY2hhbGxlbmdlLmFsbCgpO1xuICAgICAgY29uc29sZS5sb2coXCJSYXcgb24tY2hhaW4gY2hhbGxlbmdlczpcIiwgYWxsQ2hhbGxlbmdlcyk7XG5cbiAgICAgIGNvbnN0IGNoYWxsZW5nZUxpc3QgPSBhbGxDaGFsbGVuZ2VzLm1hcCgoYWNjb3VudCkgPT4gKHtcbiAgICAgICAgaWQ6IGFjY291bnQucHVibGljS2V5LnRvU3RyaW5nKCksXG4gICAgICAgIGNyZWF0b3I6IGFjY291bnQuYWNjb3VudC5jcmVhdG9yLnRvU3RyaW5nKCksXG4gICAgICAgIGxpY2hlc3NVc2VybmFtZTogXCJcIiwgLy8gU3RpbGwgbWFuYWdlZCBpbiBmcm9udGVuZCBmb3Igbm93XG4gICAgICAgIHdhZ2VyQW1vdW50OiBhY2NvdW50LmFjY291bnQud2FnZXJBbW91bnQudG9OdW1iZXIoKSAvIDFlOSxcbiAgICAgICAgaXNDb21wbGV0ZTogYWNjb3VudC5hY2NvdW50LmlzQ29tcGxldGUsXG4gICAgICAgIGlzQWN0aXZlOiBhY2NvdW50LmFjY291bnQuaXNBY3RpdmUsXG4gICAgICAgIGNoYWxsZW5nZXI6IGFjY291bnQuYWNjb3VudC5jaGFsbGVuZ2VyLnRvU3RyaW5nKCksXG4gICAgICAgIGNyZWF0ZWRBdDogYWNjb3VudC5hY2NvdW50LmNyZWF0ZWRBdC50b051bWJlcigpLFxuICAgICAgICBtZXRhZGF0YTogYWNjb3VudC5hY2NvdW50Lm1ldGFkYXRhLCAvLyBGZXRjaCBtZXRhZGF0YVxuICAgICAgICBzdGF0czoge1xuICAgICAgICAgIG1hdGNoSWQ6IFwiXCIsXG4gICAgICAgICAgcGxheWVyU3RhdHM6IHtcbiAgICAgICAgICAgIHJlc3VsdDogXCJkcmF3XCIgYXMgXCJkcmF3XCIgfCBcIndpblwiIHwgXCJsb3NzXCIsXG4gICAgICAgICAgICB2YXJpYW50OiBcIlN0YW5kYXJkXCIsXG4gICAgICAgICAgICBzcGVlZDogXCJVbmtub3duXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pKTtcbiAgICAgIHNldENoYWxsZW5nZXMoY2hhbGxlbmdlTGlzdCk7XG4gICAgICBzZXRMYXN0RmV0Y2gobm93KTtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmV0Y2hlZCBjaGFsbGVuZ2VzOlwiLCBjaGFsbGVuZ2VMaXN0KTtcbiAgICAgIHJldHVybiBjaGFsbGVuZ2VMaXN0O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBmZXRjaCBjaGFsbGVuZ2VzXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gY2hhbGxlbmdlcztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFjY2VwdENoYWxsZW5nZSA9IGFzeW5jICh7IGNoYWxsZW5nZUlkIH06IEFjY2VwdENoYWxsZW5nZVBhcmFtcykgPT4ge1xuICAgIGlmICghd2FsbGV0LmNvbm5lY3RlZCB8fCAhcHJvZ3JhbSkge1xuICAgICAgc2V0RXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIGNvbnN0IGFjY2VwdENoYWxsZW5nZUl4ID0gYXdhaXQgcHJvZ3JhbS5tZXRob2RzXG4gICAgICAgIC5hY2NlcHRDaGFsbGVuZ2UoKVxuICAgICAgICAuYWNjb3VudHMoe1xuICAgICAgICAgIGNoYWxsZW5nZTogbmV3IFB1YmxpY0tleShjaGFsbGVuZ2VJZCksXG4gICAgICAgICAgY2hhbGxlbmdlcjogd2FsbGV0LnB1YmxpY0tleSEsXG4gICAgICAgICAgc3lzdGVtUHJvZ3JhbTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICAgIH0pXG4gICAgICAgIC5pbnN0cnVjdGlvbigpO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChhY2NlcHRDaGFsbGVuZ2VJeCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgcHJvZ3JhbS5wcm92aWRlci5jb25uZWN0aW9uXG4gICAgICApO1xuICAgICAgYXdhaXQgcHJvZ3JhbS5wcm92aWRlci5jb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUpO1xuICAgICAgY29uc29sZS5sb2coXCJDaGFsbGVuZ2UgYWNjZXB0ZWQsIHNpZ25hdHVyZTpcIiwgc2lnbmF0dXJlKTtcbiAgICAgIGF3YWl0IGdldENoYWxsZW5nZXMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBhY2NlcHQgY2hhbGxlbmdlXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBjb21wbGV0ZUNoYWxsZW5nZSA9IGFzeW5jICh7XG4gICAgY2hhbGxlbmdlSWQsXG4gICAgd2lubmVyLFxuICAgIHN0YXRzLFxuICB9OiBDb21wbGV0ZUNoYWxsZW5nZVBhcmFtcykgPT4ge1xuICAgIGlmICghd2FsbGV0LmNvbm5lY3RlZCB8fCAhcHJvZ3JhbSkge1xuICAgICAgc2V0RXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIGNvbnN0IHprUHJvb2YgPSBCdWZmZXIuZnJvbShcIjEtMFwiKTsgLy8gUGxhY2Vob2xkZXIsIGFkanVzdCBiYXNlZCBvbiBhY3R1YWwgZ2FtZSByZXN1bHRcbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2hhbGxlbmdlSXggPSBhd2FpdCBwcm9ncmFtLm1ldGhvZHNcbiAgICAgICAgLmNvbXBsZXRlQ2hhbGxlbmdlKG5ldyBQdWJsaWNLZXkod2lubmVyKSwgemtQcm9vZilcbiAgICAgICAgLmFjY291bnRzKHtcbiAgICAgICAgICBjaGFsbGVuZ2U6IG5ldyBQdWJsaWNLZXkoY2hhbGxlbmdlSWQpLFxuICAgICAgICAgIGNyZWF0b3I6IHdhbGxldC5wdWJsaWNLZXkhLCAvLyBBZGp1c3QgaWYgY2hhbGxlbmdlciBjb21wbGV0ZXNcbiAgICAgICAgICBjaGFsbGVuZ2VyOiB3YWxsZXQucHVibGljS2V5ISxcbiAgICAgICAgfSlcbiAgICAgICAgLmluc3RydWN0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGNvbXBsZXRlQ2hhbGxlbmdlSXgpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbihcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvblxuICAgICAgKTtcbiAgICAgIGF3YWl0IHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2hhbGxlbmdlIGNvbXBsZXRlZCwgc2lnbmF0dXJlOlwiLCBzaWduYXR1cmUpO1xuICAgICAgYXdhaXQgZ2V0Q2hhbGxlbmdlcygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRFcnJvcihcbiAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiRmFpbGVkIHRvIGNvbXBsZXRlIGNoYWxsZW5nZVwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAod2FsbGV0LmNvbm5lY3RlZCkgZ2V0Q2hhbGxlbmdlcygpO1xuICB9LCBbd2FsbGV0LmNvbm5lY3RlZF0pO1xuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ2hhbGxlbmdlLFxuICAgIGFjY2VwdENoYWxsZW5nZSxcbiAgICBjb21wbGV0ZUNoYWxsZW5nZSxcbiAgICBnZXRDaGFsbGVuZ2VzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgY2hhbGxlbmdlU3RhdHVzLFxuICAgIGNoYWxsZW5nZXMsXG4gIH07XG59O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlV2FsbGV0IiwiUHVibGljS2V5IiwiVHJhbnNhY3Rpb24iLCJTeXN0ZW1Qcm9ncmFtIiwidXNlUHJvZ3JhbSIsInVzZUNoYWxsZW5nZSIsIndhbGxldCIsInByb2dyYW0iLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJjaGFsbGVuZ2VTdGF0dXMiLCJzZXRDaGFsbGVuZ2VTdGF0dXMiLCJjaGFsbGVuZ2VzIiwic2V0Q2hhbGxlbmdlcyIsImxhc3RGZXRjaCIsInNldExhc3RGZXRjaCIsImNyZWF0ZUNoYWxsZW5nZSIsIndhZ2VyQW1vdW50IiwibGljaGVzc1VzZXJuYW1lIiwibWV0YWRhdGEiLCJzdGF0cyIsImNvbm5lY3RlZCIsImNoYWxsZW5nZUtleXBhaXIiLCJ1bmlxdWUiLCJzdGF0c0hhc2giLCJVaW50OEFycmF5IiwibWF0Y2hJZCIsImhhc2giLCJyZXF1aXJlIiwic2V0Iiwic2xpY2UiLCJjcmVhdGVDaGFsbGVuZ2VJeCIsIm1ldGhvZHMiLCJhY2NvdW50cyIsImNoYWxsZW5nZSIsImNyZWF0b3IiLCJwdWJsaWNLZXkiLCJzeXN0ZW1Qcm9ncmFtIiwicHJvZ3JhbUlkIiwiaW5zdHJ1Y3Rpb24iLCJ0cmFuc2FjdGlvbiIsImFkZCIsInNpZ25hdHVyZSIsInNlbmRUcmFuc2FjdGlvbiIsInByb3ZpZGVyIiwiY29ubmVjdGlvbiIsImNvbmZpcm1UcmFuc2FjdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJuZXdDaGFsbGVuZ2UiLCJpZCIsInRvU3RyaW5nIiwiaXNDb21wbGV0ZSIsImlzQWN0aXZlIiwiY2hhbGxlbmdlciIsImRlZmF1bHQiLCJjcmVhdGVkQXQiLCJEYXRlIiwibm93IiwicGxheWVyU3RhdHMiLCJyZXN1bHQiLCJ2YXJpYW50Iiwic3BlZWQiLCJwcmV2IiwiZ2V0Q2hhbGxlbmdlcyIsImVyciIsIkVycm9yIiwibWVzc2FnZSIsImFsbENoYWxsZW5nZXMiLCJhY2NvdW50IiwiYWxsIiwiY2hhbGxlbmdlTGlzdCIsIm1hcCIsInRvTnVtYmVyIiwiYWNjZXB0Q2hhbGxlbmdlIiwiY2hhbGxlbmdlSWQiLCJhY2NlcHRDaGFsbGVuZ2VJeCIsImNvbXBsZXRlQ2hhbGxlbmdlIiwid2lubmVyIiwiemtQcm9vZiIsIkJ1ZmZlciIsImZyb20iLCJjb21wbGV0ZUNoYWxsZW5nZUl4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./hooks/useChallenge.ts\n"));

/***/ })

});