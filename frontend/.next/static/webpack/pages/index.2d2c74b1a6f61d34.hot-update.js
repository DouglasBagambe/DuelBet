"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./hooks/useChallenge.ts":
/*!*******************************!*\
  !*** ./hooks/useChallenge.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChallenge: () => (/* binding */ useChallenge)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"../node_modules/@solana/wallet-adapter-react/lib/esm/index.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"../node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _useProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useProgram */ \"./hooks/useProgram.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../node_modules/buffer/index.js\")[\"Buffer\"];\n// frontend/hooks/useChallenge.ts\n\n\n\n\nconst useChallenge = ()=>{\n    const wallet = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__.useWallet)();\n    const { program } = (0,_useProgram__WEBPACK_IMPORTED_MODULE_2__.useProgram)();\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [challengeStatus, setChallengeStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"idle\");\n    const [challenges, setChallenges] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [lastFetch, setLastFetch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const createChallenge = async (param)=>{\n        let { wagerAmount, lichessUsername, stats } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return null;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            setChallengeStatus(\"creating\");\n            const challengeKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.unique();\n            const statsHash = new Uint8Array(32); // Your contract expects a 32-byte hash\n            if (stats === null || stats === void 0 ? void 0 : stats.matchId) {\n                const hash = (__webpack_require__(/*! @solana/web3.js */ \"../node_modules/@solana/web3.js/lib/index.browser.esm.js\").hash)(stats.matchId); // Simple hash for now\n                statsHash.set(hash.slice(0, 32));\n            }\n            const createChallengeIx = await program.methods.createChallenge(wagerAmount, statsHash).accounts({\n                challenge: challengeKeypair,\n                creator: wallet.publicKey,\n                systemProgram: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.SystemProgram.programId\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(createChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature, \"confirmed\");\n            console.log(\"Challenge created, signature:\", signature);\n            const newChallenge = {\n                id: challengeKeypair.toString(),\n                creator: wallet.publicKey.toString(),\n                lichessUsername,\n                wagerAmount,\n                isComplete: false,\n                isActive: true,\n                challenger: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.default.toString(),\n                createdAt: Date.now() / 1000,\n                stats: stats || {\n                    matchId: \"\",\n                    playerStats: {\n                        result: \"draw\",\n                        variant: \"Standard\",\n                        speed: \"Unknown\"\n                    }\n                }\n            };\n            setChallenges((prev)=>[\n                    ...prev,\n                    newChallenge\n                ]);\n            setChallengeStatus(\"active\");\n            await getChallenges(); // Fetch updated on-chain list\n            return challengeKeypair.toString();\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to create challenge\");\n            return null;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const getChallenges = async ()=>{\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return [];\n        }\n        const now = Date.now();\n        if (now - lastFetch < 10000) {\n            console.log(\"Rate limit hit, skipping fetch\");\n            return challenges;\n        }\n        try {\n            setLoading(true);\n            const allChallenges = await program.account.challenge.all();\n            console.log(\"Raw on-chain challenges:\", allChallenges);\n            const challengeList = allChallenges.map((account)=>({\n                    id: account.publicKey.toString(),\n                    creator: account.account.creator.toString(),\n                    lichessUsername: \"\",\n                    wagerAmount: account.account.wagerAmount.toNumber() / 1e9,\n                    isComplete: account.account.isComplete,\n                    isActive: account.account.isActive,\n                    challenger: account.account.challenger.toString(),\n                    createdAt: account.account.createdAt.toNumber(),\n                    stats: {\n                        matchId: \"\",\n                        playerStats: {\n                            result: \"draw\",\n                            variant: \"Standard\",\n                            speed: \"Unknown\"\n                        }\n                    }\n                }));\n            setChallenges(challengeList);\n            setLastFetch(now);\n            console.log(\"Fetched challenges:\", challengeList);\n            return challengeList;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to fetch challenges\");\n            return challenges;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const acceptChallenge = async (param)=>{\n        let { challengeId } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return false;\n        }\n        try {\n            setLoading(true);\n            const acceptChallengeIx = await program.methods.acceptChallenge().accounts({\n                challenge: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(challengeId),\n                challenger: wallet.publicKey,\n                systemProgram: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.SystemProgram.programId\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(acceptChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature);\n            console.log(\"Challenge accepted, signature:\", signature);\n            await getChallenges();\n            return true;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to accept challenge\");\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const completeChallenge = async (param)=>{\n        let { challengeId, winner, stats } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return false;\n        }\n        try {\n            setLoading(true);\n            const zkProof = Buffer.from(\"1-0\"); // Placeholder, adjust based on actual game result\n            const completeChallengeIx = await program.methods.completeChallenge(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(winner), zkProof).accounts({\n                challenge: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(challengeId),\n                creator: wallet.publicKey,\n                challenger: wallet.publicKey\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(completeChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature);\n            console.log(\"Challenge completed, signature:\", signature);\n            await getChallenges();\n            return true;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to complete challenge\");\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChallenge.useEffect\": ()=>{\n            if (wallet.connected) getChallenges();\n        }\n    }[\"useChallenge.useEffect\"], [\n        wallet.connected\n    ]);\n    return {\n        createChallenge,\n        acceptChallenge,\n        completeChallenge,\n        getChallenges,\n        loading,\n        error,\n        challengeStatus,\n        challenges\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TyxDQUM5QzZDLGlCQUFpQixDQUFDLElBQUk3RSxzREFBU0EsQ0FBQzhFLFNBQVNDLFNBQ3pDOUMsUUFBUSxDQUFDO2dCQUNSQyxXQUFXLElBQUlsQyxzREFBU0EsQ0FBQzJFO2dCQUN6QnhDLFNBQVM5QixPQUFPK0IsU0FBUztnQkFDekJrQixZQUFZakQsT0FBTytCLFNBQVM7WUFDOUIsR0FDQ0csV0FBVztZQUVkLE1BQU1DLGNBQWMsSUFBSXZDLHdEQUFXQSxHQUFHd0MsR0FBRyxDQUFDeUM7WUFDMUMsTUFBTXhDLFlBQVksTUFBTXJDLE9BQU9zQyxlQUFlLENBQzVDSCxhQUNBbEMsUUFBUXNDLFFBQVEsQ0FBQ0MsVUFBVTtZQUU3QixNQUFNdkMsUUFBUXNDLFFBQVEsQ0FBQ0MsVUFBVSxDQUFDQyxrQkFBa0IsQ0FBQ0o7WUFDckRLLFFBQVFDLEdBQUcsQ0FBQyxtQ0FBbUNOO1lBQy9DLE1BQU1zQjtZQUNOLE9BQU87UUFDVCxFQUFFLE9BQU9DLEtBQUs7WUFDWnZELFNBQ0V1RCxlQUFlQyxRQUFRRCxJQUFJRSxPQUFPLEdBQUc7WUFFdkMsT0FBTztRQUNULFNBQVU7WUFDUjNELFdBQVc7UUFDYjtJQUNGO0lBRUFYLGdEQUFTQTtrQ0FBQztZQUNSLElBQUlRLE9BQU9nQixTQUFTLEVBQUUyQztRQUN4QjtpQ0FBRztRQUFDM0QsT0FBT2dCLFNBQVM7S0FBQztJQUVyQixPQUFPO1FBQ0xKO1FBQ0F5RDtRQUNBRztRQUNBYjtRQUNBekQ7UUFDQUU7UUFDQUU7UUFDQUU7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9ob21lL2RiL1Byb2plY3RzL0R1ZWxCZXQvZnJvbnRlbmQvaG9va3MvdXNlQ2hhbGxlbmdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZyb250ZW5kL2hvb2tzL3VzZUNoYWxsZW5nZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlV2FsbGV0IH0gZnJvbSBcIkBzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3RcIjtcbmltcG9ydCB7IFB1YmxpY0tleSwgVHJhbnNhY3Rpb24sIFN5c3RlbVByb2dyYW0gfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG5pbXBvcnQgeyB1c2VQcm9ncmFtIH0gZnJvbSBcIi4vdXNlUHJvZ3JhbVwiO1xuaW1wb3J0IHtcbiAgQ3JlYXRlQ2hhbGxlbmdlUGFyYW1zLFxuICBBY2NlcHRDaGFsbGVuZ2VQYXJhbXMsXG4gIENvbXBsZXRlQ2hhbGxlbmdlUGFyYW1zLFxuICBDaGFsbGVuZ2VTdGF0dXMsXG4gIENoYWxsZW5nZSxcbn0gZnJvbSBcIkAvdHlwZXNcIjtcblxuZXhwb3J0IGNvbnN0IHVzZUNoYWxsZW5nZSA9ICgpID0+IHtcbiAgY29uc3Qgd2FsbGV0ID0gdXNlV2FsbGV0KCk7XG4gIGNvbnN0IHsgcHJvZ3JhbSB9ID0gdXNlUHJvZ3JhbSgpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjaGFsbGVuZ2VTdGF0dXMsIHNldENoYWxsZW5nZVN0YXR1c10gPVxuICAgIHVzZVN0YXRlPENoYWxsZW5nZVN0YXR1cz4oXCJpZGxlXCIpO1xuICBjb25zdCBbY2hhbGxlbmdlcywgc2V0Q2hhbGxlbmdlc10gPSB1c2VTdGF0ZTxDaGFsbGVuZ2VbXT4oW10pO1xuICBjb25zdCBbbGFzdEZldGNoLCBzZXRMYXN0RmV0Y2hdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcblxuICBjb25zdCBjcmVhdGVDaGFsbGVuZ2UgPSBhc3luYyAoe1xuICAgIHdhZ2VyQW1vdW50LFxuICAgIGxpY2hlc3NVc2VybmFtZSxcbiAgICBzdGF0cyxcbiAgfTogQ3JlYXRlQ2hhbGxlbmdlUGFyYW1zKSA9PiB7XG4gICAgaWYgKCF3YWxsZXQuY29ubmVjdGVkIHx8ICFwcm9ncmFtKSB7XG4gICAgICBzZXRFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgIHNldENoYWxsZW5nZVN0YXR1cyhcImNyZWF0aW5nXCIpO1xuXG4gICAgICBjb25zdCBjaGFsbGVuZ2VLZXlwYWlyID0gUHVibGljS2V5LnVuaXF1ZSgpO1xuICAgICAgY29uc3Qgc3RhdHNIYXNoID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyAvLyBZb3VyIGNvbnRyYWN0IGV4cGVjdHMgYSAzMi1ieXRlIGhhc2hcbiAgICAgIGlmIChzdGF0cz8ubWF0Y2hJZCkge1xuICAgICAgICBjb25zdCBoYXNoID0gcmVxdWlyZShcIkBzb2xhbmEvd2ViMy5qc1wiKS5oYXNoKHN0YXRzLm1hdGNoSWQpOyAvLyBTaW1wbGUgaGFzaCBmb3Igbm93XG4gICAgICAgIHN0YXRzSGFzaC5zZXQoaGFzaC5zbGljZSgwLCAzMikpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjcmVhdGVDaGFsbGVuZ2VJeCA9IGF3YWl0IHByb2dyYW0ubWV0aG9kc1xuICAgICAgICAuY3JlYXRlQ2hhbGxlbmdlKHdhZ2VyQW1vdW50LCBzdGF0c0hhc2gpXG4gICAgICAgIC5hY2NvdW50cyh7XG4gICAgICAgICAgY2hhbGxlbmdlOiBjaGFsbGVuZ2VLZXlwYWlyLFxuICAgICAgICAgIGNyZWF0b3I6IHdhbGxldC5wdWJsaWNLZXkhLFxuICAgICAgICAgIHN5c3RlbVByb2dyYW06IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgICB9KVxuICAgICAgICAuaW5zdHJ1Y3Rpb24oKTtcblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoY3JlYXRlQ2hhbGxlbmdlSXgpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbihcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvblxuICAgICAgKTtcbiAgICAgIGF3YWl0IHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgXCJjb25maXJtZWRcIlxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2hhbGxlbmdlIGNyZWF0ZWQsIHNpZ25hdHVyZTpcIiwgc2lnbmF0dXJlKTtcblxuICAgICAgY29uc3QgbmV3Q2hhbGxlbmdlOiBDaGFsbGVuZ2UgPSB7XG4gICAgICAgIGlkOiBjaGFsbGVuZ2VLZXlwYWlyLnRvU3RyaW5nKCksXG4gICAgICAgIGNyZWF0b3I6IHdhbGxldC5wdWJsaWNLZXkhLnRvU3RyaW5nKCksXG4gICAgICAgIGxpY2hlc3NVc2VybmFtZSxcbiAgICAgICAgd2FnZXJBbW91bnQsXG4gICAgICAgIGlzQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY2hhbGxlbmdlcjogUHVibGljS2V5LmRlZmF1bHQudG9TdHJpbmcoKSxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpIC8gMTAwMCxcbiAgICAgICAgc3RhdHM6IHN0YXRzIHx8IHtcbiAgICAgICAgICBtYXRjaElkOiBcIlwiLFxuICAgICAgICAgIHBsYXllclN0YXRzOiB7XG4gICAgICAgICAgICByZXN1bHQ6IFwiZHJhd1wiLFxuICAgICAgICAgICAgdmFyaWFudDogXCJTdGFuZGFyZFwiLFxuICAgICAgICAgICAgc3BlZWQ6IFwiVW5rbm93blwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgc2V0Q2hhbGxlbmdlcygocHJldikgPT4gWy4uLnByZXYsIG5ld0NoYWxsZW5nZV0pO1xuICAgICAgc2V0Q2hhbGxlbmdlU3RhdHVzKFwiYWN0aXZlXCIpO1xuICAgICAgYXdhaXQgZ2V0Q2hhbGxlbmdlcygpOyAvLyBGZXRjaCB1cGRhdGVkIG9uLWNoYWluIGxpc3RcbiAgICAgIHJldHVybiBjaGFsbGVuZ2VLZXlwYWlyLnRvU3RyaW5nKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRFcnJvcihcbiAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFsbGVuZ2VcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0Q2hhbGxlbmdlcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXdhbGxldC5jb25uZWN0ZWQgfHwgIXByb2dyYW0pIHtcbiAgICAgIHNldEVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gbGFzdEZldGNoIDwgMTAwMDApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiUmF0ZSBsaW1pdCBoaXQsIHNraXBwaW5nIGZldGNoXCIpO1xuICAgICAgcmV0dXJuIGNoYWxsZW5nZXM7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBhbGxDaGFsbGVuZ2VzID0gYXdhaXQgcHJvZ3JhbS5hY2NvdW50LmNoYWxsZW5nZS5hbGwoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiUmF3IG9uLWNoYWluIGNoYWxsZW5nZXM6XCIsIGFsbENoYWxsZW5nZXMpO1xuXG4gICAgICBjb25zdCBjaGFsbGVuZ2VMaXN0ID0gYWxsQ2hhbGxlbmdlcy5tYXAoKGFjY291bnQpID0+ICh7XG4gICAgICAgIGlkOiBhY2NvdW50LnB1YmxpY0tleS50b1N0cmluZygpLFxuICAgICAgICBjcmVhdG9yOiBhY2NvdW50LmFjY291bnQuY3JlYXRvci50b1N0cmluZygpLFxuICAgICAgICBsaWNoZXNzVXNlcm5hbWU6IFwiXCIsIC8vIE5vdCBzdG9yZWQgb24tY2hhaW4sIGhhbmRsZSBzZXBhcmF0ZWx5IGlmIG5lZWRlZFxuICAgICAgICB3YWdlckFtb3VudDogYWNjb3VudC5hY2NvdW50LndhZ2VyQW1vdW50LnRvTnVtYmVyKCkgLyAxZTksIC8vIENvbnZlcnQgbGFtcG9ydHMgdG8gU09MXG4gICAgICAgIGlzQ29tcGxldGU6IGFjY291bnQuYWNjb3VudC5pc0NvbXBsZXRlLFxuICAgICAgICBpc0FjdGl2ZTogYWNjb3VudC5hY2NvdW50LmlzQWN0aXZlLFxuICAgICAgICBjaGFsbGVuZ2VyOiBhY2NvdW50LmFjY291bnQuY2hhbGxlbmdlci50b1N0cmluZygpLFxuICAgICAgICBjcmVhdGVkQXQ6IGFjY291bnQuYWNjb3VudC5jcmVhdGVkQXQudG9OdW1iZXIoKSxcbiAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICBtYXRjaElkOiBcIlwiLFxuICAgICAgICAgIHBsYXllclN0YXRzOiB7XG4gICAgICAgICAgICByZXN1bHQ6IFwiZHJhd1wiIGFzIFwiZHJhd1wiIHwgXCJ3aW5cIiB8IFwibG9zc1wiLFxuICAgICAgICAgICAgdmFyaWFudDogXCJTdGFuZGFyZFwiLFxuICAgICAgICAgICAgc3BlZWQ6IFwiVW5rbm93blwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sIC8vIFBsYWNlaG9sZGVyXG4gICAgICB9KSk7XG4gICAgICBzZXRDaGFsbGVuZ2VzKGNoYWxsZW5nZUxpc3QpO1xuICAgICAgc2V0TGFzdEZldGNoKG5vdyk7XG4gICAgICBjb25zb2xlLmxvZyhcIkZldGNoZWQgY2hhbGxlbmdlczpcIiwgY2hhbGxlbmdlTGlzdCk7XG4gICAgICByZXR1cm4gY2hhbGxlbmdlTGlzdDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gZmV0Y2ggY2hhbGxlbmdlc1wiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNoYWxsZW5nZXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhY2NlcHRDaGFsbGVuZ2UgPSBhc3luYyAoeyBjaGFsbGVuZ2VJZCB9OiBBY2NlcHRDaGFsbGVuZ2VQYXJhbXMpID0+IHtcbiAgICBpZiAoIXdhbGxldC5jb25uZWN0ZWQgfHwgIXByb2dyYW0pIHtcbiAgICAgIHNldEVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBhY2NlcHRDaGFsbGVuZ2VJeCA9IGF3YWl0IHByb2dyYW0ubWV0aG9kc1xuICAgICAgICAuYWNjZXB0Q2hhbGxlbmdlKClcbiAgICAgICAgLmFjY291bnRzKHtcbiAgICAgICAgICBjaGFsbGVuZ2U6IG5ldyBQdWJsaWNLZXkoY2hhbGxlbmdlSWQpLFxuICAgICAgICAgIGNoYWxsZW5nZXI6IHdhbGxldC5wdWJsaWNLZXkhLFxuICAgICAgICAgIHN5c3RlbVByb2dyYW06IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgICB9KVxuICAgICAgICAuaW5zdHJ1Y3Rpb24oKTtcblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoYWNjZXB0Q2hhbGxlbmdlSXgpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbihcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvblxuICAgICAgKTtcbiAgICAgIGF3YWl0IHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2hhbGxlbmdlIGFjY2VwdGVkLCBzaWduYXR1cmU6XCIsIHNpZ25hdHVyZSk7XG4gICAgICBhd2FpdCBnZXRDaGFsbGVuZ2VzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gYWNjZXB0IGNoYWxsZW5nZVwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY29tcGxldGVDaGFsbGVuZ2UgPSBhc3luYyAoe1xuICAgIGNoYWxsZW5nZUlkLFxuICAgIHdpbm5lcixcbiAgICBzdGF0cyxcbiAgfTogQ29tcGxldGVDaGFsbGVuZ2VQYXJhbXMpID0+IHtcbiAgICBpZiAoIXdhbGxldC5jb25uZWN0ZWQgfHwgIXByb2dyYW0pIHtcbiAgICAgIHNldEVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCB6a1Byb29mID0gQnVmZmVyLmZyb20oXCIxLTBcIik7IC8vIFBsYWNlaG9sZGVyLCBhZGp1c3QgYmFzZWQgb24gYWN0dWFsIGdhbWUgcmVzdWx0XG4gICAgICBjb25zdCBjb21wbGV0ZUNoYWxsZW5nZUl4ID0gYXdhaXQgcHJvZ3JhbS5tZXRob2RzXG4gICAgICAgIC5jb21wbGV0ZUNoYWxsZW5nZShuZXcgUHVibGljS2V5KHdpbm5lciksIHprUHJvb2YpXG4gICAgICAgIC5hY2NvdW50cyh7XG4gICAgICAgICAgY2hhbGxlbmdlOiBuZXcgUHVibGljS2V5KGNoYWxsZW5nZUlkKSxcbiAgICAgICAgICBjcmVhdG9yOiB3YWxsZXQucHVibGljS2V5ISwgLy8gQWRqdXN0IGlmIGNoYWxsZW5nZXIgY29tcGxldGVzXG4gICAgICAgICAgY2hhbGxlbmdlcjogd2FsbGV0LnB1YmxpY0tleSEsXG4gICAgICAgIH0pXG4gICAgICAgIC5pbnN0cnVjdGlvbigpO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChjb21wbGV0ZUNoYWxsZW5nZUl4KTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24oXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBwcm9ncmFtLnByb3ZpZGVyLmNvbm5lY3Rpb25cbiAgICAgICk7XG4gICAgICBhd2FpdCBwcm9ncmFtLnByb3ZpZGVyLmNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSk7XG4gICAgICBjb25zb2xlLmxvZyhcIkNoYWxsZW5nZSBjb21wbGV0ZWQsIHNpZ25hdHVyZTpcIiwgc2lnbmF0dXJlKTtcbiAgICAgIGF3YWl0IGdldENoYWxsZW5nZXMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBjb21wbGV0ZSBjaGFsbGVuZ2VcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHdhbGxldC5jb25uZWN0ZWQpIGdldENoYWxsZW5nZXMoKTtcbiAgfSwgW3dhbGxldC5jb25uZWN0ZWRdKTtcblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUNoYWxsZW5nZSxcbiAgICBhY2NlcHRDaGFsbGVuZ2UsXG4gICAgY29tcGxldGVDaGFsbGVuZ2UsXG4gICAgZ2V0Q2hhbGxlbmdlcyxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIGNoYWxsZW5nZVN0YXR1cyxcbiAgICBjaGFsbGVuZ2VzLFxuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVdhbGxldCIsIlB1YmxpY0tleSIsIlRyYW5zYWN0aW9uIiwiU3lzdGVtUHJvZ3JhbSIsInVzZVByb2dyYW0iLCJ1c2VDaGFsbGVuZ2UiLCJ3YWxsZXQiLCJwcm9ncmFtIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiY2hhbGxlbmdlU3RhdHVzIiwic2V0Q2hhbGxlbmdlU3RhdHVzIiwiY2hhbGxlbmdlcyIsInNldENoYWxsZW5nZXMiLCJsYXN0RmV0Y2giLCJzZXRMYXN0RmV0Y2giLCJjcmVhdGVDaGFsbGVuZ2UiLCJ3YWdlckFtb3VudCIsImxpY2hlc3NVc2VybmFtZSIsInN0YXRzIiwiY29ubmVjdGVkIiwiY2hhbGxlbmdlS2V5cGFpciIsInVuaXF1ZSIsInN0YXRzSGFzaCIsIlVpbnQ4QXJyYXkiLCJtYXRjaElkIiwiaGFzaCIsInJlcXVpcmUiLCJzZXQiLCJzbGljZSIsImNyZWF0ZUNoYWxsZW5nZUl4IiwibWV0aG9kcyIsImFjY291bnRzIiwiY2hhbGxlbmdlIiwiY3JlYXRvciIsInB1YmxpY0tleSIsInN5c3RlbVByb2dyYW0iLCJwcm9ncmFtSWQiLCJpbnN0cnVjdGlvbiIsInRyYW5zYWN0aW9uIiwiYWRkIiwic2lnbmF0dXJlIiwic2VuZFRyYW5zYWN0aW9uIiwicHJvdmlkZXIiLCJjb25uZWN0aW9uIiwiY29uZmlybVRyYW5zYWN0aW9uIiwiY29uc29sZSIsImxvZyIsIm5ld0NoYWxsZW5nZSIsImlkIiwidG9TdHJpbmciLCJpc0NvbXBsZXRlIiwiaXNBY3RpdmUiLCJjaGFsbGVuZ2VyIiwiZGVmYXVsdCIsImNyZWF0ZWRBdCIsIkRhdGUiLCJub3ciLCJwbGF5ZXJTdGF0cyIsInJlc3VsdCIsInZhcmlhbnQiLCJzcGVlZCIsInByZXYiLCJnZXRDaGFsbGVuZ2VzIiwiZXJyIiwiRXJyb3IiLCJtZXNzYWdlIiwiYWxsQ2hhbGxlbmdlcyIsImFjY291bnQiLCJhbGwiLCJjaGFsbGVuZ2VMaXN0IiwibWFwIiwidG9OdW1iZXIiLCJhY2NlcHRDaGFsbGVuZ2UiLCJjaGFsbGVuZ2VJZCIsImFjY2VwdENoYWxsZW5nZUl4IiwiY29tcGxldGVDaGFsbGVuZ2UiLCJ3aW5uZXIiLCJ6a1Byb29mIiwiQnVmZmVyIiwiZnJvbSIsImNvbXBsZXRlQ2hhbGxlbmdlSXgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./hooks/useChallenge.ts\n"));

/***/ })

});