"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./hooks/useChallenge.ts":
/*!*******************************!*\
  !*** ./hooks/useChallenge.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChallenge: () => (/* binding */ useChallenge)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"../node_modules/@solana/wallet-adapter-react/lib/esm/index.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"../node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _useProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useProgram */ \"./hooks/useProgram.ts\");\n// frontend/components/hooks/useChallenge.ts\n // Add useEffect\n\n\n\nconst useChallenge = ()=>{\n    const wallet = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__.useWallet)();\n    const { program } = (0,_useProgram__WEBPACK_IMPORTED_MODULE_2__.useProgram)();\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [challengeStatus, setChallengeStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"idle\");\n    const [challengeAccount, setChallengeAccount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    // const [challenges, setChallenges] = useState<Challenge[]>([]);\n    const [lastFetch, setLastFetch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // At the top of useChallenge.ts\n    const getStoredChallenges = ()=>{\n        const stored = localStorage.getItem(\"challenges\");\n        return stored ? JSON.parse(stored) : [];\n    };\n    const [challenges, setChallenges] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getStoredChallenges());\n    const createChallenge = async (param)=>{\n        let { wagerAmount, lichessUsername } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return null;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            setChallengeStatus(\"creating\");\n            const challengeKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.unique();\n            const statsHash = new Uint8Array(32).fill(1);\n            const lamports = Math.round(wagerAmount * 1e9);\n            const createChallengeIx = await program.methods.createChallenge(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(lamports.toString()), statsHash).accounts({\n                challenge: challengeKeypair,\n                creator: wallet.publicKey,\n                systemProgram: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.SystemProgram.programId\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(createChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature, \"confirmed\");\n            console.log(\"Transaction signature:\", signature);\n            const newChallenge = {\n                id: challengeKeypair.toString(),\n                creator: wallet.publicKey.toString(),\n                lichessUsername,\n                wagerAmount,\n                isComplete: false,\n                stats: {\n                    matchId: \"\",\n                    playerStats: {\n                        result: \"draw\",\n                        variant: \"Standard\",\n                        speed: \"Unknown\"\n                    }\n                }\n            };\n            setChallenges((prev)=>{\n                const updatedChallenges = [\n                    ...prev,\n                    newChallenge\n                ];\n                console.log(\"Challenges updated in createChallenge:\", updatedChallenges); // New debug log\n                localStorage.setItem(\"challenges\", JSON.stringify(updatedChallenges)); // Ensure persistence\n                return updatedChallenges;\n            });\n            setChallengeStatus(\"active\");\n            setChallengeAccount(challengeKeypair.toString());\n            await getChallenges(); // Try to fetch updated list\n            return challengeKeypair.toString();\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Failed to create challenge\";\n            console.error(\"Create challenge error:\", errorMessage);\n            setError(errorMessage);\n            setChallengeStatus(\"idle\");\n            return null;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const getChallenges = async ()=>{\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return [];\n        }\n        const now = Date.now();\n        if (now - lastFetch < 10000) {\n            console.log(\"Rate limit hit, skipping fetch\");\n            return challenges;\n        }\n        try {\n            setLoading(true);\n            const filters = [\n                {\n                    memcmp: {\n                        offset: 8,\n                        bytes: wallet.publicKey.toString()\n                    }\n                }\n            ];\n            console.log(\"Attempting to fetch challenges with filters:\", filters); // Debug\n            const allChallenges = await program.account.challenge.all(filters);\n            const challengeList = allChallenges.map((account)=>({\n                    id: account.publicKey.toString(),\n                    creator: account.account.creator.toString(),\n                    lichessUsername: account.account.lichessUsername || \"\",\n                    wagerAmount: account.account.wagerAmount.toNumber() / 1e9,\n                    isComplete: account.account.isComplete || false,\n                    stats: account.account.stats || {\n                        matchId: \"\",\n                        playerStats: {\n                            result: \"draw\",\n                            variant: \"Standard\",\n                            speed: \"Unknown\"\n                        }\n                    }\n                }));\n            setChallenges(challengeList);\n            localStorage.setItem(\"challenges\", JSON.stringify(challengeList));\n            setLastFetch(now);\n            console.log(\"Successfully fetched challenges:\", challengeList);\n            return challengeList;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Failed to fetch challenges\";\n            if (errorMessage.includes(\"429\")) {\n                console.warn(\"Rate limit hit, retrying after delay...\", errorMessage);\n                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                return getChallenges();\n            }\n            console.error(\"Fetch failed, falling back to localStorage:\", errorMessage);\n            const storedChallenges = getStoredChallenges();\n            setChallenges(storedChallenges);\n            console.log(\"Fallback challenges from localStorage:\", storedChallenges);\n            return storedChallenges;\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChallenge.useEffect\": ()=>{\n            if (wallet.connected) getChallenges();\n        }\n    }[\"useChallenge.useEffect\"], [\n        wallet.connected\n    ]);\n    const acceptChallenge = async (param)=>{\n        let { challengeId, wagerAmount, lichessUsername } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return false;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            const acceptChallengeIx = await program.methods.acceptChallenge().accounts({\n                challenge: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(challengeId),\n                challenger: wallet.publicKey,\n                systemProgram: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.SystemProgram.programId\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(acceptChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature);\n            setChallengeStatus(\"accepted\");\n            return true;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to accept challenge\");\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const completeChallenge = async (param)=>{\n        let { challengeId, winner, stats } = param;\n        if (!wallet.connected || !program) {\n            setError(\"Wallet not connected\");\n            return false;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            const zkProof = new Uint8Array(32).fill(0); // Placeholder for Lichess ZK proof (e.g., game result verification)\n            const completeChallengeIx = await program.methods.completeChallenge(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(winner), zkProof).accounts({\n                challenge: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(challengeId),\n                creator: wallet.publicKey,\n                challenger: wallet.publicKey\n            }).instruction();\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction().add(completeChallengeIx);\n            const signature = await wallet.sendTransaction(transaction, program.provider.connection);\n            await program.provider.connection.confirmTransaction(signature);\n            setChallengeStatus(\"completed\");\n            return true;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to complete challenge\");\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        createChallenge,\n        acceptChallenge,\n        completeChallenge,\n        getChallenges,\n        loading,\n        error,\n        challengeStatus,\n        challengeAccount\n    };\n};\nfunction setLastFetch(now) {\n    throw new Error(\"Function not implemented.\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDbUQ7WUFDMUMsTUFBTWxELFlBQVksTUFBTTVDLE9BQU82QyxlQUFlLENBQzVDSCxhQUNBekMsUUFBUTZDLFFBQVEsQ0FBQ0MsVUFBVTtZQUc3QixNQUFNOUMsUUFBUTZDLFFBQVEsQ0FBQ0MsVUFBVSxDQUFDQyxrQkFBa0IsQ0FBQ0o7WUFDckRyQyxtQkFBbUI7WUFDbkIsT0FBTztRQUNULEVBQUUsT0FBTzBELEtBQUs7WUFDWjVELFNBQ0U0RCxlQUFlRSxRQUFRRixJQUFJRyxPQUFPLEdBQUc7WUFFdkMsT0FBTztRQUNULFNBQVU7WUFDUmpFLFdBQVc7UUFDYjtJQUNGO0lBRUEsT0FBTztRQUNMaUI7UUFDQW1FO1FBQ0FJO1FBQ0EzQjtRQUNBOUQ7UUFDQUU7UUFDQUU7UUFDQUU7SUFDRjtBQUNGLEVBQUU7QUFDRixTQUFTRyxhQUFhMEQsR0FBVztJQUMvQixNQUFNLElBQUlGLE1BQU07QUFDbEIiLCJzb3VyY2VzIjpbIi9ob21lL2RiL1Byb2plY3RzL0R1ZWxCZXQvZnJvbnRlbmQvaG9va3MvdXNlQ2hhbGxlbmdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZyb250ZW5kL2NvbXBvbmVudHMvaG9va3MvdXNlQ2hhbGxlbmdlLnRzXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjsgLy8gQWRkIHVzZUVmZmVjdFxuaW1wb3J0IHsgdXNlV2FsbGV0IH0gZnJvbSBcIkBzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3RcIjtcbmltcG9ydCB7IFB1YmxpY0tleSwgVHJhbnNhY3Rpb24sIFN5c3RlbVByb2dyYW0gfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG5pbXBvcnQgeyB1c2VQcm9ncmFtIH0gZnJvbSBcIi4vdXNlUHJvZ3JhbVwiO1xuaW1wb3J0IHtcbiAgQ3JlYXRlQ2hhbGxlbmdlUGFyYW1zLFxuICBBY2NlcHRDaGFsbGVuZ2VQYXJhbXMsXG4gIENvbXBsZXRlQ2hhbGxlbmdlUGFyYW1zLFxuICBDaGFsbGVuZ2VTdGF0dXMsXG4gIENoYWxsZW5nZSxcbn0gZnJvbSBcIkAvdHlwZXNcIjtcblxuZXhwb3J0IGNvbnN0IHVzZUNoYWxsZW5nZSA9ICgpID0+IHtcbiAgY29uc3Qgd2FsbGV0ID0gdXNlV2FsbGV0KCk7XG4gIGNvbnN0IHsgcHJvZ3JhbSB9ID0gdXNlUHJvZ3JhbSgpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjaGFsbGVuZ2VTdGF0dXMsIHNldENoYWxsZW5nZVN0YXR1c10gPVxuICAgIHVzZVN0YXRlPENoYWxsZW5nZVN0YXR1cz4oXCJpZGxlXCIpO1xuICBjb25zdCBbY2hhbGxlbmdlQWNjb3VudCwgc2V0Q2hhbGxlbmdlQWNjb3VudF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xuICAvLyBjb25zdCBbY2hhbGxlbmdlcywgc2V0Q2hhbGxlbmdlc10gPSB1c2VTdGF0ZTxDaGFsbGVuZ2VbXT4oW10pO1xuICBjb25zdCBbbGFzdEZldGNoLCBzZXRMYXN0RmV0Y2hdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcblxuICAvLyBBdCB0aGUgdG9wIG9mIHVzZUNoYWxsZW5nZS50c1xuICBjb25zdCBnZXRTdG9yZWRDaGFsbGVuZ2VzID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiY2hhbGxlbmdlc1wiKTtcbiAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogW107XG4gIH07XG5cbiAgY29uc3QgW2NoYWxsZW5nZXMsIHNldENoYWxsZW5nZXNdID0gdXNlU3RhdGU8Q2hhbGxlbmdlW10+KFxuICAgIGdldFN0b3JlZENoYWxsZW5nZXMoKVxuICApO1xuXG4gIGNvbnN0IGNyZWF0ZUNoYWxsZW5nZSA9IGFzeW5jICh7XG4gICAgd2FnZXJBbW91bnQsXG4gICAgbGljaGVzc1VzZXJuYW1lLFxuICB9OiBDcmVhdGVDaGFsbGVuZ2VQYXJhbXMpID0+IHtcbiAgICBpZiAoIXdhbGxldC5jb25uZWN0ZWQgfHwgIXByb2dyYW0pIHtcbiAgICAgIHNldEVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgc2V0Q2hhbGxlbmdlU3RhdHVzKFwiY3JlYXRpbmdcIik7XG5cbiAgICAgIGNvbnN0IGNoYWxsZW5nZUtleXBhaXIgPSBQdWJsaWNLZXkudW5pcXVlKCk7XG4gICAgICBjb25zdCBzdGF0c0hhc2ggPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgxKTtcbiAgICAgIGNvbnN0IGxhbXBvcnRzID0gTWF0aC5yb3VuZCh3YWdlckFtb3VudCAqIDFlOSk7XG5cbiAgICAgIGNvbnN0IGNyZWF0ZUNoYWxsZW5nZUl4ID0gYXdhaXQgcHJvZ3JhbS5tZXRob2RzXG4gICAgICAgIC5jcmVhdGVDaGFsbGVuZ2UobmV3IFB1YmxpY0tleShsYW1wb3J0cy50b1N0cmluZygpKSwgc3RhdHNIYXNoKVxuICAgICAgICAuYWNjb3VudHMoe1xuICAgICAgICAgIGNoYWxsZW5nZTogY2hhbGxlbmdlS2V5cGFpcixcbiAgICAgICAgICBjcmVhdG9yOiB3YWxsZXQucHVibGljS2V5ISxcbiAgICAgICAgICBzeXN0ZW1Qcm9ncmFtOiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgfSlcbiAgICAgICAgLmluc3RydWN0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGNyZWF0ZUNoYWxsZW5nZUl4KTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24oXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBwcm9ncmFtLnByb3ZpZGVyLmNvbm5lY3Rpb25cbiAgICAgICk7XG4gICAgICBhd2FpdCBwcm9ncmFtLnByb3ZpZGVyLmNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIFwiY29uZmlybWVkXCJcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhcIlRyYW5zYWN0aW9uIHNpZ25hdHVyZTpcIiwgc2lnbmF0dXJlKTtcblxuICAgICAgY29uc3QgbmV3Q2hhbGxlbmdlOiBDaGFsbGVuZ2UgPSB7XG4gICAgICAgIGlkOiBjaGFsbGVuZ2VLZXlwYWlyLnRvU3RyaW5nKCksXG4gICAgICAgIGNyZWF0b3I6IHdhbGxldC5wdWJsaWNLZXkhLnRvU3RyaW5nKCksXG4gICAgICAgIGxpY2hlc3NVc2VybmFtZSxcbiAgICAgICAgd2FnZXJBbW91bnQsXG4gICAgICAgIGlzQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICBzdGF0czoge1xuICAgICAgICAgIG1hdGNoSWQ6IFwiXCIsXG4gICAgICAgICAgcGxheWVyU3RhdHM6IHtcbiAgICAgICAgICAgIHJlc3VsdDogXCJkcmF3XCIsXG4gICAgICAgICAgICB2YXJpYW50OiBcIlN0YW5kYXJkXCIsXG4gICAgICAgICAgICBzcGVlZDogXCJVbmtub3duXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBzZXRDaGFsbGVuZ2VzKChwcmV2KSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDaGFsbGVuZ2VzID0gWy4uLnByZXYsIG5ld0NoYWxsZW5nZV07XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiQ2hhbGxlbmdlcyB1cGRhdGVkIGluIGNyZWF0ZUNoYWxsZW5nZTpcIixcbiAgICAgICAgICB1cGRhdGVkQ2hhbGxlbmdlc1xuICAgICAgICApOyAvLyBOZXcgZGVidWcgbG9nXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY2hhbGxlbmdlc1wiLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkQ2hhbGxlbmdlcykpOyAvLyBFbnN1cmUgcGVyc2lzdGVuY2VcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRDaGFsbGVuZ2VzO1xuICAgICAgfSk7XG4gICAgICBzZXRDaGFsbGVuZ2VTdGF0dXMoXCJhY3RpdmVcIik7XG4gICAgICBzZXRDaGFsbGVuZ2VBY2NvdW50KGNoYWxsZW5nZUtleXBhaXIudG9TdHJpbmcoKSk7XG4gICAgICBhd2FpdCBnZXRDaGFsbGVuZ2VzKCk7IC8vIFRyeSB0byBmZXRjaCB1cGRhdGVkIGxpc3RcbiAgICAgIHJldHVybiBjaGFsbGVuZ2VLZXlwYWlyLnRvU3RyaW5nKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gY3JlYXRlIGNoYWxsZW5nZVwiO1xuICAgICAgY29uc29sZS5lcnJvcihcIkNyZWF0ZSBjaGFsbGVuZ2UgZXJyb3I6XCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgc2V0Q2hhbGxlbmdlU3RhdHVzKFwiaWRsZVwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0Q2hhbGxlbmdlcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXdhbGxldC5jb25uZWN0ZWQgfHwgIXByb2dyYW0pIHtcbiAgICAgIHNldEVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gbGFzdEZldGNoIDwgMTAwMDApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiUmF0ZSBsaW1pdCBoaXQsIHNraXBwaW5nIGZldGNoXCIpO1xuICAgICAgcmV0dXJuIGNoYWxsZW5nZXM7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBmaWx0ZXJzID0gW1xuICAgICAgICB7IG1lbWNtcDogeyBvZmZzZXQ6IDgsIGJ5dGVzOiB3YWxsZXQucHVibGljS2V5IS50b1N0cmluZygpIH0gfSxcbiAgICAgIF07XG4gICAgICBjb25zb2xlLmxvZyhcIkF0dGVtcHRpbmcgdG8gZmV0Y2ggY2hhbGxlbmdlcyB3aXRoIGZpbHRlcnM6XCIsIGZpbHRlcnMpOyAvLyBEZWJ1Z1xuICAgICAgY29uc3QgYWxsQ2hhbGxlbmdlcyA9IGF3YWl0IHByb2dyYW0uYWNjb3VudC5jaGFsbGVuZ2UuYWxsKGZpbHRlcnMpO1xuICAgICAgY29uc3QgY2hhbGxlbmdlTGlzdCA9IGFsbENoYWxsZW5nZXMubWFwKChhY2NvdW50KSA9PiAoe1xuICAgICAgICBpZDogYWNjb3VudC5wdWJsaWNLZXkudG9TdHJpbmcoKSxcbiAgICAgICAgY3JlYXRvcjogYWNjb3VudC5hY2NvdW50LmNyZWF0b3IudG9TdHJpbmcoKSxcbiAgICAgICAgbGljaGVzc1VzZXJuYW1lOiBhY2NvdW50LmFjY291bnQubGljaGVzc1VzZXJuYW1lIHx8IFwiXCIsXG4gICAgICAgIHdhZ2VyQW1vdW50OiBhY2NvdW50LmFjY291bnQud2FnZXJBbW91bnQudG9OdW1iZXIoKSAvIDFlOSxcbiAgICAgICAgaXNDb21wbGV0ZTogYWNjb3VudC5hY2NvdW50LmlzQ29tcGxldGUgfHwgZmFsc2UsXG4gICAgICAgIHN0YXRzOiBhY2NvdW50LmFjY291bnQuc3RhdHMgfHwge1xuICAgICAgICAgIG1hdGNoSWQ6IFwiXCIsXG4gICAgICAgICAgcGxheWVyU3RhdHM6IHtcbiAgICAgICAgICAgIHJlc3VsdDogXCJkcmF3XCIsXG4gICAgICAgICAgICB2YXJpYW50OiBcIlN0YW5kYXJkXCIsXG4gICAgICAgICAgICBzcGVlZDogXCJVbmtub3duXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pKTtcbiAgICAgIHNldENoYWxsZW5nZXMoY2hhbGxlbmdlTGlzdCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNoYWxsZW5nZXNcIiwgSlNPTi5zdHJpbmdpZnkoY2hhbGxlbmdlTGlzdCkpO1xuICAgICAgc2V0TGFzdEZldGNoKG5vdyk7XG4gICAgICBjb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSBmZXRjaGVkIGNoYWxsZW5nZXM6XCIsIGNoYWxsZW5nZUxpc3QpO1xuICAgICAgcmV0dXJuIGNoYWxsZW5nZUxpc3Q7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gZmV0Y2ggY2hhbGxlbmdlc1wiO1xuICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIjQyOVwiKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJSYXRlIGxpbWl0IGhpdCwgcmV0cnlpbmcgYWZ0ZXIgZGVsYXkuLi5cIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpO1xuICAgICAgICByZXR1cm4gZ2V0Q2hhbGxlbmdlcygpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJGZXRjaCBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBsb2NhbFN0b3JhZ2U6XCIsXG4gICAgICAgIGVycm9yTWVzc2FnZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHN0b3JlZENoYWxsZW5nZXMgPSBnZXRTdG9yZWRDaGFsbGVuZ2VzKCk7XG4gICAgICBzZXRDaGFsbGVuZ2VzKHN0b3JlZENoYWxsZW5nZXMpO1xuICAgICAgY29uc29sZS5sb2coXCJGYWxsYmFjayBjaGFsbGVuZ2VzIGZyb20gbG9jYWxTdG9yYWdlOlwiLCBzdG9yZWRDaGFsbGVuZ2VzKTtcbiAgICAgIHJldHVybiBzdG9yZWRDaGFsbGVuZ2VzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAod2FsbGV0LmNvbm5lY3RlZCkgZ2V0Q2hhbGxlbmdlcygpO1xuICB9LCBbd2FsbGV0LmNvbm5lY3RlZF0pO1xuXG4gIGNvbnN0IGFjY2VwdENoYWxsZW5nZSA9IGFzeW5jICh7XG4gICAgY2hhbGxlbmdlSWQsXG4gICAgd2FnZXJBbW91bnQsXG4gICAgbGljaGVzc1VzZXJuYW1lLCAvLyBSZXBsYWNlZCByaW90SWQgd2l0aCBsaWNoZXNzVXNlcm5hbWVcbiAgfTogQWNjZXB0Q2hhbGxlbmdlUGFyYW1zKSA9PiB7XG4gICAgaWYgKCF3YWxsZXQuY29ubmVjdGVkIHx8ICFwcm9ncmFtKSB7XG4gICAgICBzZXRFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnN0IGFjY2VwdENoYWxsZW5nZUl4ID0gYXdhaXQgcHJvZ3JhbS5tZXRob2RzXG4gICAgICAgIC5hY2NlcHRDaGFsbGVuZ2UoKVxuICAgICAgICAuYWNjb3VudHMoe1xuICAgICAgICAgIGNoYWxsZW5nZTogbmV3IFB1YmxpY0tleShjaGFsbGVuZ2VJZCksXG4gICAgICAgICAgY2hhbGxlbmdlcjogd2FsbGV0LnB1YmxpY0tleSEsXG4gICAgICAgICAgc3lzdGVtUHJvZ3JhbTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICAgIH0pXG4gICAgICAgIC5pbnN0cnVjdGlvbigpO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChhY2NlcHRDaGFsbGVuZ2VJeCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgcHJvZ3JhbS5wcm92aWRlci5jb25uZWN0aW9uXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBwcm9ncmFtLnByb3ZpZGVyLmNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSk7XG4gICAgICBzZXRDaGFsbGVuZ2VTdGF0dXMoXCJhY2NlcHRlZFwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBhY2NlcHQgY2hhbGxlbmdlXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBjb21wbGV0ZUNoYWxsZW5nZSA9IGFzeW5jICh7XG4gICAgY2hhbGxlbmdlSWQsXG4gICAgd2lubmVyLFxuICAgIHN0YXRzLCAvLyBSZW1vdmVkIHNwZWNpZmljIExvTCBzdGF0cyAoa2lsbHMsIGRlYXRocywgYXNzaXN0cyksIGtlZXBpbmcgYXMgZ2VuZXJpYyBzdGF0c1xuICB9OiBDb21wbGV0ZUNoYWxsZW5nZVBhcmFtcykgPT4ge1xuICAgIGlmICghd2FsbGV0LmNvbm5lY3RlZCB8fCAhcHJvZ3JhbSkge1xuICAgICAgc2V0RXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICBjb25zdCB6a1Byb29mID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMCk7IC8vIFBsYWNlaG9sZGVyIGZvciBMaWNoZXNzIFpLIHByb29mIChlLmcuLCBnYW1lIHJlc3VsdCB2ZXJpZmljYXRpb24pXG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2hhbGxlbmdlSXggPSBhd2FpdCBwcm9ncmFtLm1ldGhvZHNcbiAgICAgICAgLmNvbXBsZXRlQ2hhbGxlbmdlKG5ldyBQdWJsaWNLZXkod2lubmVyKSwgemtQcm9vZilcbiAgICAgICAgLmFjY291bnRzKHtcbiAgICAgICAgICBjaGFsbGVuZ2U6IG5ldyBQdWJsaWNLZXkoY2hhbGxlbmdlSWQpLFxuICAgICAgICAgIGNyZWF0b3I6IHdhbGxldC5wdWJsaWNLZXkhLCAvLyBBc3N1bWluZyBjcmVhdG9yIG9yIGNoYWxsZW5nZXIgY2FuIGNvbXBsZXRlLCBhZGp1c3QgYmFzZWQgb24geW91ciBwcm9ncmFtIGxvZ2ljXG4gICAgICAgICAgY2hhbGxlbmdlcjogd2FsbGV0LnB1YmxpY0tleSEsXG4gICAgICAgIH0pXG4gICAgICAgIC5pbnN0cnVjdGlvbigpO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChjb21wbGV0ZUNoYWxsZW5nZUl4KTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24oXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBwcm9ncmFtLnByb3ZpZGVyLmNvbm5lY3Rpb25cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHByb2dyYW0ucHJvdmlkZXIuY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlKTtcbiAgICAgIHNldENoYWxsZW5nZVN0YXR1cyhcImNvbXBsZXRlZFwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBjb21wbGV0ZSBjaGFsbGVuZ2VcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ2hhbGxlbmdlLFxuICAgIGFjY2VwdENoYWxsZW5nZSxcbiAgICBjb21wbGV0ZUNoYWxsZW5nZSxcbiAgICBnZXRDaGFsbGVuZ2VzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgY2hhbGxlbmdlU3RhdHVzLFxuICAgIGNoYWxsZW5nZUFjY291bnQsXG4gIH07XG59O1xuZnVuY3Rpb24gc2V0TGFzdEZldGNoKG5vdzogbnVtYmVyKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZC5cIik7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VXYWxsZXQiLCJQdWJsaWNLZXkiLCJUcmFuc2FjdGlvbiIsIlN5c3RlbVByb2dyYW0iLCJ1c2VQcm9ncmFtIiwidXNlQ2hhbGxlbmdlIiwid2FsbGV0IiwicHJvZ3JhbSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImNoYWxsZW5nZVN0YXR1cyIsInNldENoYWxsZW5nZVN0YXR1cyIsImNoYWxsZW5nZUFjY291bnQiLCJzZXRDaGFsbGVuZ2VBY2NvdW50IiwibGFzdEZldGNoIiwic2V0TGFzdEZldGNoIiwiZ2V0U3RvcmVkQ2hhbGxlbmdlcyIsInN0b3JlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJjaGFsbGVuZ2VzIiwic2V0Q2hhbGxlbmdlcyIsImNyZWF0ZUNoYWxsZW5nZSIsIndhZ2VyQW1vdW50IiwibGljaGVzc1VzZXJuYW1lIiwiY29ubmVjdGVkIiwiY2hhbGxlbmdlS2V5cGFpciIsInVuaXF1ZSIsInN0YXRzSGFzaCIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwibGFtcG9ydHMiLCJNYXRoIiwicm91bmQiLCJjcmVhdGVDaGFsbGVuZ2VJeCIsIm1ldGhvZHMiLCJ0b1N0cmluZyIsImFjY291bnRzIiwiY2hhbGxlbmdlIiwiY3JlYXRvciIsInB1YmxpY0tleSIsInN5c3RlbVByb2dyYW0iLCJwcm9ncmFtSWQiLCJpbnN0cnVjdGlvbiIsInRyYW5zYWN0aW9uIiwiYWRkIiwic2lnbmF0dXJlIiwic2VuZFRyYW5zYWN0aW9uIiwicHJvdmlkZXIiLCJjb25uZWN0aW9uIiwiY29uZmlybVRyYW5zYWN0aW9uIiwiY29uc29sZSIsImxvZyIsIm5ld0NoYWxsZW5nZSIsImlkIiwiaXNDb21wbGV0ZSIsInN0YXRzIiwibWF0Y2hJZCIsInBsYXllclN0YXRzIiwicmVzdWx0IiwidmFyaWFudCIsInNwZWVkIiwicHJldiIsInVwZGF0ZWRDaGFsbGVuZ2VzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImdldENoYWxsZW5nZXMiLCJlcnIiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsIm1lc3NhZ2UiLCJub3ciLCJEYXRlIiwiZmlsdGVycyIsIm1lbWNtcCIsIm9mZnNldCIsImJ5dGVzIiwiYWxsQ2hhbGxlbmdlcyIsImFjY291bnQiLCJhbGwiLCJjaGFsbGVuZ2VMaXN0IiwibWFwIiwidG9OdW1iZXIiLCJpbmNsdWRlcyIsIndhcm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJzdG9yZWRDaGFsbGVuZ2VzIiwiYWNjZXB0Q2hhbGxlbmdlIiwiY2hhbGxlbmdlSWQiLCJhY2NlcHRDaGFsbGVuZ2VJeCIsImNoYWxsZW5nZXIiLCJjb21wbGV0ZUNoYWxsZW5nZSIsIndpbm5lciIsInprUHJvb2YiLCJjb21wbGV0ZUNoYWxsZW5nZUl4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./hooks/useChallenge.ts\n"));

/***/ })

});